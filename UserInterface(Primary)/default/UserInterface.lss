
UserInterface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008b4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000057  00800100  00800100  00000928  2**0
                  ALLOC
  2 .debug_aranges 000000e0  00000000  00000000  00000928  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000b27  00000000  00000000  00000a08  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000178e  00000000  00000000  0000152f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000072f  00000000  00000000  00002cbd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000010ca  00000000  00000000  000033ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000002b0  00000000  00000000  000044b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000051e  00000000  00000000  00004768  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000040a  00000000  00000000  00004c86  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000108  00000000  00000000  00005090  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 03 03 	jmp	0x606	; 0x606 <__vector_13>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 ae 02 	jmp	0x55c	; 0x55c <__vector_20>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 37 02 	jmp	0x46e	; 0x46e <__vector_24>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	c0 e0       	ldi	r28, 0x00	; 0
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 eb       	ldi	r30, 0xB4	; 180
  a0:	f8 e0       	ldi	r31, 0x08	; 8
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 30       	cpi	r26, 0x00	; 0
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a0 e0       	ldi	r26, 0x00	; 0
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a7 35       	cpi	r26, 0x57	; 87
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 83 00 	call	0x106	; 0x106 <main>
  c6:	0c 94 58 04 	jmp	0x8b0	; 0x8b0 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <delay10>:
#include <avr/wdt.h>

void InitializeUI(void);

void delay10()
{
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	0a c0       	rjmp	.+20     	; 0xe8 <delay10+0x1a>
	int i = 0;
	int j=0;
	for(i=0;i<100;i++){
		for(j=0;j<100;j++){
			DDRD &= ~_BV(UI_VOLDOWN);
  d4:	52 98       	cbi	0x0a, 2	; 10
void delay10()
{
	int i = 0;
	int j=0;
	for(i=0;i<100;i++){
		for(j=0;j<100;j++){
  d6:	01 96       	adiw	r24, 0x01	; 1
  d8:	84 36       	cpi	r24, 0x64	; 100
  da:	91 05       	cpc	r25, r1
  dc:	d9 f7       	brne	.-10     	; 0xd4 <delay10+0x6>

void delay10()
{
	int i = 0;
	int j=0;
	for(i=0;i<100;i++){
  de:	2f 5f       	subi	r18, 0xFF	; 255
  e0:	3f 4f       	sbci	r19, 0xFF	; 255
  e2:	24 36       	cpi	r18, 0x64	; 100
  e4:	31 05       	cpc	r19, r1
  e6:	19 f0       	breq	.+6      	; 0xee <delay10+0x20>
  e8:	80 e0       	ldi	r24, 0x00	; 0
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	f3 cf       	rjmp	.-26     	; 0xd4 <delay10+0x6>
  ee:	08 95       	ret

000000f0 <InitializeUI>:
 * @brief initialize basic elements of the UI board
 */
void InitializeUI(void)
{
	//Initialize the Serial comm with the main module
	init_USART_MCU();
  f0:	0e 94 9e 02 	call	0x53c	; 0x53c <init_USART_MCU>
	//Initialize the analog ports
  //TODO: why is this commented out?
	//InitializeAnalogPorts();

	//Initialize the digital input/output pins
	Initialize_Digital_IO();
  f4:	0e 94 91 00 	call	0x122	; 0x122 <Initialize_Digital_IO>

	// Initialize the timer
	initTimer();
  f8:	0e 94 e6 02 	call	0x5cc	; 0x5cc <initTimer>

	// Enable interrupts
	sei();
  fc:	78 94       	sei

	InterfaceType=1;
  fe:	81 e0       	ldi	r24, 0x01	; 1
 100:	80 93 15 01 	sts	0x0115, r24
}
 104:	08 95       	ret

00000106 <main>:
 * Executes an infinite loop, should never return
 * @return 0
 */
int main(void)
{
	InitializeUI();
 106:	0e 94 78 00 	call	0xf0	; 0xf0 <InitializeUI>
		}
	}*/

	//PORTD |= _BV(UI_STAT1);
	//delay10();
	delay10();
 10a:	0e 94 67 00 	call	0xce	; 0xce <delay10>
	//SetStatLED2(false);
	SetStatLED1(false);
 10e:	80 e0       	ldi	r24, 0x00	; 0
 110:	0e 94 0d 01 	call	0x21a	; 0x21a <SetStatLED1>
	  //SendPacket('D',SendMsgPayLoad,5);
    // Test the transmission to MCU 
    //	USART_transmitByteToMCU('P');
    
    // Check to see if timer interrupt has occurred
		if(TMR1_INT)
 114:	80 91 06 01 	lds	r24, 0x0106
 118:	88 23       	and	r24, r24
 11a:	e1 f3       	breq	.-8      	; 0x114 <main+0xe>
		{
			//SetStatLED2(false);
			TimerRoutine();
 11c:	0e 94 fd 02 	call	0x5fa	; 0x5fa <TimerRoutine>
 120:	f9 cf       	rjmp	.-14     	; 0x114 <main+0xe>

00000122 <Initialize_Digital_IO>:
#include "GlobalsUI.h"

void Initialize_Digital_IO(void)
{
	Enter1State=0;
 122:	10 92 36 01 	sts	0x0136, r1
	Enter2State=0;
 126:	10 92 00 01 	sts	0x0100, r1
	Mode1State=0;
 12a:	10 92 33 01 	sts	0x0133, r1
	Mode2State=0;
 12e:	10 92 34 01 	sts	0x0134, r1
	VolUpState=0;
 132:	10 92 35 01 	sts	0x0135, r1
	VolDownState=0;
 136:	10 92 16 01 	sts	0x0116, r1
		
	DDRC &= ~_BV(UI_BR1);	
 13a:	3c 98       	cbi	0x07, 4	; 7
	DDRC &= ~_BV(UI_BR2);
 13c:	39 98       	cbi	0x07, 1	; 7
	DDRC &= ~_BV(UI_BR3);
 13e:	3d 98       	cbi	0x07, 5	; 7
	DDRC &= ~_BV(UI_BR4);
 140:	3a 98       	cbi	0x07, 2	; 7
	DDRC &= ~_BV(UI_BR5);
 142:	3b 98       	cbi	0x07, 3	; 7
	DDRC &= ~_BV(UI_BR6);
 144:	38 98       	cbi	0x07, 0	; 7

	DDRB &= ~_BV(UI_ENTER1);
 146:	27 98       	cbi	0x04, 7	; 4
	DDRB &= ~_BV(UI_ENTER2);
 148:	26 98       	cbi	0x04, 6	; 4
	DDRB &= ~_BV(UI_MODE1);
 14a:	21 98       	cbi	0x04, 1	; 4
	DDRB &= ~_BV(UI_MODE2);
 14c:	20 98       	cbi	0x04, 0	; 4

	DDRD &= ~_BV(UI_VOLUP);
 14e:	53 98       	cbi	0x0a, 3	; 10
	DDRD &= ~_BV(UI_VOLDOWN);
 150:	52 98       	cbi	0x0a, 2	; 10
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
 152:	8a b1       	in	r24, 0x0a	; 10
 154:	80 6c       	ori	r24, 0xC0	; 192
 156:	8a b9       	out	0x0a, r24	; 10
	{
		PORTD &= ~_BV(UI_STAT1);
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 158:	5e 9a       	sbi	0x0b, 6	; 11
	{
		PORTD &= ~_BV(UI_STAT2);
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 15a:	5f 9a       	sbi	0x0b, 7	; 11
	DDRD &= ~_BV(UI_VOLDOWN);
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
	//switch off stat LEDs
	SetStatLED1(true);
	SetStatLED2(true); 
}
 15c:	08 95       	ret

0000015e <CheckCommandButtons>:

void CheckCommandButtons(void)
{
	if(!(PINB & (1<<UI_ENTER1)))
 15e:	1f 99       	sbic	0x03, 7	; 3
 160:	0a c0       	rjmp	.+20     	; 0x176 <CheckCommandButtons+0x18>
	{
		if(Enter1State==0)
 162:	80 91 36 01 	lds	r24, 0x0136
 166:	88 23       	and	r24, r24
 168:	41 f4       	brne	.+16     	; 0x17a <CheckCommandButtons+0x1c>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER1)))
 16a:	1f 99       	sbic	0x03, 7	; 3
 16c:	06 c0       	rjmp	.+12     	; 0x17a <CheckCommandButtons+0x1c>
			{
				Enter1State=1;
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	80 93 36 01 	sts	0x0136, r24
 174:	02 c0       	rjmp	.+4      	; 0x17a <CheckCommandButtons+0x1c>
			}
		}
	}
	else
	{
		Enter1State=0;
 176:	10 92 36 01 	sts	0x0136, r1
	}

	if(!(PINB & (1<<UI_ENTER2)))
 17a:	1e 99       	sbic	0x03, 6	; 3
 17c:	13 c0       	rjmp	.+38     	; 0x1a4 <CheckCommandButtons+0x46>
	{
		if(Enter2State==0)
 17e:	80 91 00 01 	lds	r24, 0x0100
 182:	88 23       	and	r24, r24
 184:	89 f4       	brne	.+34     	; 0x1a8 <CheckCommandButtons+0x4a>
 186:	88 ee       	ldi	r24, 0xE8	; 232
 188:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 18a:	28 ec       	ldi	r18, 0xC8	; 200
 18c:	30 e0       	ldi	r19, 0x00	; 0
 18e:	f9 01       	movw	r30, r18
 190:	31 97       	sbiw	r30, 0x01	; 1
 192:	f1 f7       	brne	.-4      	; 0x190 <CheckCommandButtons+0x32>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 194:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 196:	d9 f7       	brne	.-10     	; 0x18e <CheckCommandButtons+0x30>
		{
			_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER2)))
 198:	1e 99       	sbic	0x03, 6	; 3
 19a:	06 c0       	rjmp	.+12     	; 0x1a8 <CheckCommandButtons+0x4a>
			{
				Enter2State=1;
 19c:	81 e0       	ldi	r24, 0x01	; 1
 19e:	80 93 00 01 	sts	0x0100, r24
 1a2:	02 c0       	rjmp	.+4      	; 0x1a8 <CheckCommandButtons+0x4a>
			}
		}
	}
	else
	{
		Enter2State=0;
 1a4:	10 92 00 01 	sts	0x0100, r1
	}

	if(!(PINB & (1<<UI_MODE1)))
 1a8:	19 99       	sbic	0x03, 1	; 3
 1aa:	0a c0       	rjmp	.+20     	; 0x1c0 <CheckCommandButtons+0x62>
	{
		if(Mode1State==0)
 1ac:	80 91 33 01 	lds	r24, 0x0133
 1b0:	88 23       	and	r24, r24
 1b2:	41 f4       	brne	.+16     	; 0x1c4 <CheckCommandButtons+0x66>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE1)))
 1b4:	19 99       	sbic	0x03, 1	; 3
 1b6:	06 c0       	rjmp	.+12     	; 0x1c4 <CheckCommandButtons+0x66>
			{
				Mode1State=1;
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	80 93 33 01 	sts	0x0133, r24
 1be:	02 c0       	rjmp	.+4      	; 0x1c4 <CheckCommandButtons+0x66>
			}
		}
	}
	else
	{
		Mode1State=0;
 1c0:	10 92 33 01 	sts	0x0133, r1
	}

	if(!(PINB & (1<<UI_MODE2)))
 1c4:	18 99       	sbic	0x03, 0	; 3
 1c6:	0a c0       	rjmp	.+20     	; 0x1dc <CheckCommandButtons+0x7e>
	{
		if(Mode2State==0)
 1c8:	80 91 34 01 	lds	r24, 0x0134
 1cc:	88 23       	and	r24, r24
 1ce:	41 f4       	brne	.+16     	; 0x1e0 <CheckCommandButtons+0x82>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE2)))
 1d0:	18 99       	sbic	0x03, 0	; 3
 1d2:	06 c0       	rjmp	.+12     	; 0x1e0 <CheckCommandButtons+0x82>
			{
				Mode2State=1;
 1d4:	81 e0       	ldi	r24, 0x01	; 1
 1d6:	80 93 34 01 	sts	0x0134, r24
 1da:	02 c0       	rjmp	.+4      	; 0x1e0 <CheckCommandButtons+0x82>
			}
		}
	}
	else
	{
		Mode2State=0;
 1dc:	10 92 34 01 	sts	0x0134, r1
	}

	if(!(PIND & (1<<UI_VOLUP)))
 1e0:	4b 99       	sbic	0x09, 3	; 9
 1e2:	0a c0       	rjmp	.+20     	; 0x1f8 <CheckCommandButtons+0x9a>
	{
		if(VolUpState==0)
 1e4:	80 91 35 01 	lds	r24, 0x0135
 1e8:	88 23       	and	r24, r24
 1ea:	41 f4       	brne	.+16     	; 0x1fc <CheckCommandButtons+0x9e>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLUP)))
 1ec:	4b 99       	sbic	0x09, 3	; 9
 1ee:	06 c0       	rjmp	.+12     	; 0x1fc <CheckCommandButtons+0x9e>
			{
				VolUpState=1;
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	80 93 35 01 	sts	0x0135, r24
 1f6:	02 c0       	rjmp	.+4      	; 0x1fc <CheckCommandButtons+0x9e>
			}
		}
	}
	else
	{
		VolUpState=0;
 1f8:	10 92 35 01 	sts	0x0135, r1
	}

	if(!(PIND & (1<<UI_VOLDOWN)))
 1fc:	4a 99       	sbic	0x09, 2	; 9
 1fe:	0a c0       	rjmp	.+20     	; 0x214 <CheckCommandButtons+0xb6>
	{
		if(VolDownState==0)
 200:	80 91 16 01 	lds	r24, 0x0116
 204:	88 23       	and	r24, r24
 206:	41 f4       	brne	.+16     	; 0x218 <CheckCommandButtons+0xba>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLDOWN)))
 208:	4a 99       	sbic	0x09, 2	; 9
 20a:	06 c0       	rjmp	.+12     	; 0x218 <CheckCommandButtons+0xba>
			{
				VolDownState=1;
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	80 93 16 01 	sts	0x0116, r24
 212:	08 95       	ret
			}
		}
	}
	else
	{
		VolDownState=0;
 214:	10 92 16 01 	sts	0x0116, r1
 218:	08 95       	ret

0000021a <SetStatLED1>:
}
*/

void SetStatLED1(bool bState)
{
	if(!bState)
 21a:	88 23       	and	r24, r24
 21c:	11 f4       	brne	.+4      	; 0x222 <SetStatLED1+0x8>
	{
		PORTD &= ~_BV(UI_STAT1);
 21e:	5e 98       	cbi	0x0b, 6	; 11
 220:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 222:	5e 9a       	sbi	0x0b, 6	; 11
 224:	08 95       	ret

00000226 <SetStatLED2>:
	}
}

void SetStatLED2(bool bState)
{
	if(!bState)
 226:	88 23       	and	r24, r24
 228:	11 f4       	brne	.+4      	; 0x22e <SetStatLED2+0x8>
	{
		PORTD &= ~_BV(UI_STAT2);
 22a:	5f 98       	cbi	0x0b, 7	; 11
 22c:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 22e:	5f 9a       	sbi	0x0b, 7	; 11
 230:	08 95       	ret

00000232 <VolDownTask>:
	SendPacket('D',(char*)SendMsgPayLoad,1);
}

void VolDownTask(void)
{
	SendMsgPayLoad[0]=0x05;
 232:	85 e0       	ldi	r24, 0x05	; 5
 234:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 238:	84 e4       	ldi	r24, 0x44	; 68
 23a:	61 e0       	ldi	r22, 0x01	; 1
 23c:	71 e0       	ldi	r23, 0x01	; 1
 23e:	41 e0       	ldi	r20, 0x01	; 1
 240:	50 e0       	ldi	r21, 0x00	; 0
 242:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
}
 246:	08 95       	ret

00000248 <VolUpTask>:
	SendPacket('D',(char*)SendMsgPayLoad,1);
}

void VolUpTask(void)
{
	SendMsgPayLoad[0]=0x06;
 248:	86 e0       	ldi	r24, 0x06	; 6
 24a:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 24e:	84 e4       	ldi	r24, 0x44	; 68
 250:	61 e0       	ldi	r22, 0x01	; 1
 252:	71 e0       	ldi	r23, 0x01	; 1
 254:	41 e0       	ldi	r20, 0x01	; 1
 256:	50 e0       	ldi	r21, 0x00	; 0
 258:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
}
 25c:	08 95       	ret

0000025e <Mode2Task>:

void SetStatLED1(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT1);
 25e:	5e 98       	cbi	0x0b, 6	; 11
}

void Mode2Task(void)
{
	SetStatLED1(false);
	SendMsgPayLoad[0]=0x04;
 260:	84 e0       	ldi	r24, 0x04	; 4
 262:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 266:	84 e4       	ldi	r24, 0x44	; 68
 268:	61 e0       	ldi	r22, 0x01	; 1
 26a:	71 e0       	ldi	r23, 0x01	; 1
 26c:	41 e0       	ldi	r20, 0x01	; 1
 26e:	50 e0       	ldi	r21, 0x00	; 0
 270:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
}
 274:	08 95       	ret

00000276 <Mode1Task>:
	{
		PORTD &= ~_BV(UI_STAT1);
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 276:	5e 9a       	sbi	0x0b, 6	; 11
}

void Mode1Task(void)
{
	SetStatLED1(true);
	SendMsgPayLoad[0]=0x03;
 278:	83 e0       	ldi	r24, 0x03	; 3
 27a:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 27e:	84 e4       	ldi	r24, 0x44	; 68
 280:	61 e0       	ldi	r22, 0x01	; 1
 282:	71 e0       	ldi	r23, 0x01	; 1
 284:	41 e0       	ldi	r20, 0x01	; 1
 286:	50 e0       	ldi	r21, 0x00	; 0
 288:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
}
 28c:	08 95       	ret

0000028e <Enter2Task>:

void SetStatLED2(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT2);
 28e:	5f 98       	cbi	0x0b, 7	; 11
}

void Enter2Task(void)
{
	SetStatLED2(false);
	SendMsgPayLoad[0]=0x02;
 290:	82 e0       	ldi	r24, 0x02	; 2
 292:	80 93 01 01 	sts	0x0101, r24
	SendMsgPayLoad[1]='E';
 296:	85 e4       	ldi	r24, 0x45	; 69
 298:	80 93 02 01 	sts	0x0102, r24
	SendPacket('D',(char*)SendMsgPayLoad,2);
 29c:	84 e4       	ldi	r24, 0x44	; 68
 29e:	61 e0       	ldi	r22, 0x01	; 1
 2a0:	71 e0       	ldi	r23, 0x01	; 1
 2a2:	42 e0       	ldi	r20, 0x02	; 2
 2a4:	50 e0       	ldi	r21, 0x00	; 0
 2a6:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
}
 2aa:	08 95       	ret

000002ac <Enter1Task>:
	{
		PORTD &= ~_BV(UI_STAT2);
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 2ac:	5f 9a       	sbi	0x0b, 7	; 11
}

void Enter1Task(void)
{
	SetStatLED2(true);
	SendMsgPayLoad[0]=0x01;
 2ae:	81 e0       	ldi	r24, 0x01	; 1
 2b0:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 2b4:	84 e4       	ldi	r24, 0x44	; 68
 2b6:	61 e0       	ldi	r22, 0x01	; 1
 2b8:	71 e0       	ldi	r23, 0x01	; 1
 2ba:	41 e0       	ldi	r20, 0x01	; 1
 2bc:	50 e0       	ldi	r21, 0x00	; 0
 2be:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
	CaptureCellValue();
 2c2:	0e 94 c9 03 	call	0x792	; 0x792 <CaptureCellValue>
}
 2c6:	08 95       	ret

000002c8 <RunCommandTasks>:
	}
}

void RunCommandTasks(void)
{
	if(Enter1State==1)
 2c8:	80 91 36 01 	lds	r24, 0x0136
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	29 f4       	brne	.+10     	; 0x2da <RunCommandTasks+0x12>
	{
		Enter1Task();
 2d0:	0e 94 56 01 	call	0x2ac	; 0x2ac <Enter1Task>
		Enter1State=2;	//Set it as used
 2d4:	82 e0       	ldi	r24, 0x02	; 2
 2d6:	80 93 36 01 	sts	0x0136, r24
	}
	if(Enter2State==1)
 2da:	80 91 00 01 	lds	r24, 0x0100
 2de:	81 30       	cpi	r24, 0x01	; 1
 2e0:	29 f4       	brne	.+10     	; 0x2ec <RunCommandTasks+0x24>
	{
		Enter2Task();
 2e2:	0e 94 47 01 	call	0x28e	; 0x28e <Enter2Task>
		Enter2State=2;	//Set it as used
 2e6:	82 e0       	ldi	r24, 0x02	; 2
 2e8:	80 93 00 01 	sts	0x0100, r24
	}
	if(Mode1State==1)
 2ec:	80 91 33 01 	lds	r24, 0x0133
 2f0:	81 30       	cpi	r24, 0x01	; 1
 2f2:	29 f4       	brne	.+10     	; 0x2fe <RunCommandTasks+0x36>
	{
		Mode1Task();
 2f4:	0e 94 3b 01 	call	0x276	; 0x276 <Mode1Task>
		Mode1State=2;	//Set it as used
 2f8:	82 e0       	ldi	r24, 0x02	; 2
 2fa:	80 93 33 01 	sts	0x0133, r24
	}
	if(Mode2State==1)
 2fe:	80 91 34 01 	lds	r24, 0x0134
 302:	81 30       	cpi	r24, 0x01	; 1
 304:	29 f4       	brne	.+10     	; 0x310 <RunCommandTasks+0x48>
	{
		Mode2Task();
 306:	0e 94 2f 01 	call	0x25e	; 0x25e <Mode2Task>
		Mode2State=2;	//Set it as used
 30a:	82 e0       	ldi	r24, 0x02	; 2
 30c:	80 93 34 01 	sts	0x0134, r24
	}
	if((VolDownState>=1)&&(VolUpState>=1)) //Flip the keyboard
 310:	80 91 16 01 	lds	r24, 0x0116
 314:	88 23       	and	r24, r24
 316:	71 f0       	breq	.+28     	; 0x334 <RunCommandTasks+0x6c>
 318:	80 91 35 01 	lds	r24, 0x0135
 31c:	88 23       	and	r24, r24
 31e:	51 f0       	breq	.+20     	; 0x334 <RunCommandTasks+0x6c>
	{
		if(InterfaceType==1)
 320:	80 91 15 01 	lds	r24, 0x0115
 324:	81 30       	cpi	r24, 0x01	; 1
 326:	11 f4       	brne	.+4      	; 0x32c <RunCommandTasks+0x64>
		{
			InterfaceType=2;
 328:	82 e0       	ldi	r24, 0x02	; 2
 32a:	01 c0       	rjmp	.+2      	; 0x32e <RunCommandTasks+0x66>
		}
		else
		{
			InterfaceType=1;
 32c:	81 e0       	ldi	r24, 0x01	; 1
 32e:	80 93 15 01 	sts	0x0115, r24
 332:	08 95       	ret
		}
		return;
	}
	if(VolUpState==1)
 334:	80 91 35 01 	lds	r24, 0x0135
 338:	81 30       	cpi	r24, 0x01	; 1
 33a:	29 f4       	brne	.+10     	; 0x346 <RunCommandTasks+0x7e>
	{
		VolUpTask();
 33c:	0e 94 24 01 	call	0x248	; 0x248 <VolUpTask>
		VolUpState=2;	//Set it as used
 340:	82 e0       	ldi	r24, 0x02	; 2
 342:	80 93 35 01 	sts	0x0135, r24
	}
	if(VolDownState==1)
 346:	80 91 16 01 	lds	r24, 0x0116
 34a:	81 30       	cpi	r24, 0x01	; 1
 34c:	29 f4       	brne	.+10     	; 0x358 <RunCommandTasks+0x90>
	{
		VolDownTask();
 34e:	0e 94 19 01 	call	0x232	; 0x232 <VolDownTask>
		VolDownState=2;	//Set it as used
 352:	82 e0       	ldi	r24, 0x02	; 2
 354:	80 93 16 01 	sts	0x0116, r24
 358:	08 95       	ret

0000035a <InitializeAnalogPorts>:
bool LED_ONOFF;

void InitializeAnalogPorts()
{

	ADCSRA |= 0xEF;
 35a:	ea e7       	ldi	r30, 0x7A	; 122
 35c:	f0 e0       	ldi	r31, 0x00	; 0
 35e:	80 81       	ld	r24, Z
 360:	8f 6e       	ori	r24, 0xEF	; 239
 362:	80 83       	st	Z, r24
	ADCSRB=0x00;
 364:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x67;
 368:	87 e6       	ldi	r24, 0x67	; 103
 36a:	80 93 7c 00 	sts	0x007C, r24
	DIDR0=0x3F;
 36e:	8f e3       	ldi	r24, 0x3F	; 63
 370:	80 93 7e 00 	sts	0x007E, r24
	int i=0;
	for(i=0;i<6;i++)
	{
		ADC_LastVal[i]=0;
 374:	10 92 0a 01 	sts	0x010A, r1
 378:	10 92 09 01 	sts	0x0109, r1
 37c:	10 92 0c 01 	sts	0x010C, r1
 380:	10 92 0b 01 	sts	0x010B, r1
 384:	10 92 0e 01 	sts	0x010E, r1
 388:	10 92 0d 01 	sts	0x010D, r1
 38c:	10 92 10 01 	sts	0x0110, r1
 390:	10 92 0f 01 	sts	0x010F, r1
 394:	10 92 12 01 	sts	0x0112, r1
 398:	10 92 11 01 	sts	0x0111, r1
 39c:	10 92 14 01 	sts	0x0114, r1
 3a0:	10 92 13 01 	sts	0x0113, r1
	}
	LED_ONOFF=false;
 3a4:	10 92 3a 01 	sts	0x013A, r1
}
 3a8:	08 95       	ret

000003aa <StartMeasurement>:
----------------------------------------------------------
THESE ARE NOT BEING USED
*/
void StartMeasurement(void)
{
	ADCSRA =0xCE;
 3aa:	8e ec       	ldi	r24, 0xCE	; 206
 3ac:	80 93 7a 00 	sts	0x007A, r24
}
 3b0:	08 95       	ret

000003b2 <StopMeasurement>:

void StopMeasurement(void)
{

}
 3b2:	08 95       	ret

000003b4 <MeasureInput>:
 3b4:	80 e1       	ldi	r24, 0x10	; 16
 3b6:	97 e2       	ldi	r25, 0x27	; 39
 3b8:	01 97       	sbiw	r24, 0x01	; 1
 3ba:	f1 f7       	brne	.-4      	; 0x3b8 <MeasureInput+0x4>
 3bc:	e0 e0       	ldi	r30, 0x00	; 0
 3be:	f0 e0       	ldi	r31, 0x00	; 0
 3c0:	60 e0       	ldi	r22, 0x00	; 0
 3c2:	70 e0       	ldi	r23, 0x00	; 0
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
	{
		ADC_COMPLETE=false;
 3c4:	a0 e1       	ldi	r26, 0x10	; 16
 3c6:	b7 e2       	ldi	r27, 0x27	; 39
 3c8:	10 92 08 01 	sts	0x0108, r1
 3cc:	cd 01       	movw	r24, r26
 3ce:	01 97       	sbiw	r24, 0x01	; 1
 3d0:	f1 f7       	brne	.-4      	; 0x3ce <MeasureInput+0x1a>
		//StartMeasurement();
		_delay_ms(5);
		valADC=((ADCH<<8) | ADCL);
 3d2:	80 91 79 00 	lds	r24, 0x0079
 3d6:	20 91 78 00 	lds	r18, 0x0078
 3da:	58 2f       	mov	r21, r24
 3dc:	40 e0       	ldi	r20, 0x00	; 0
 3de:	30 e0       	ldi	r19, 0x00	; 0
 3e0:	24 2b       	or	r18, r20
 3e2:	35 2b       	or	r19, r21
 3e4:	30 93 3c 01 	sts	0x013C, r19
 3e8:	20 93 3b 01 	sts	0x013B, r18
		//while(!ADC_COMPLETE);
		iVal+=valADC;
 3ec:	80 91 3b 01 	lds	r24, 0x013B
 3f0:	90 91 3c 01 	lds	r25, 0x013C
 3f4:	e8 0f       	add	r30, r24
 3f6:	f9 1f       	adc	r31, r25
 3f8:	cd 01       	movw	r24, r26
 3fa:	01 97       	sbiw	r24, 0x01	; 1
 3fc:	f1 f7       	brne	.-4      	; 0x3fa <MeasureInput+0x46>
{
	//ADMUX = 0x40 + whichADC;
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
 3fe:	6f 5f       	subi	r22, 0xFF	; 255
 400:	7f 4f       	sbci	r23, 0xFF	; 255
 402:	6a 30       	cpi	r22, 0x0A	; 10
 404:	71 05       	cpc	r23, r1
 406:	01 f7       	brne	.-64     	; 0x3c8 <MeasureInput+0x14>
 408:	cf 01       	movw	r24, r30
 40a:	6a e0       	ldi	r22, 0x0A	; 10
 40c:	70 e0       	ldi	r23, 0x00	; 0
 40e:	0e 94 44 04 	call	0x888	; 0x888 <__udivmodhi4>
 412:	cb 01       	movw	r24, r22
		iVal+=valADC;
		_delay_ms(5);
	}
	iVal=iVal/10;
	return iVal;
}
 414:	08 95       	ret

00000416 <analog10>:
	//uint16_t tADC0=0;
	uint16_t tADC[10];
	//uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
 416:	80 5c       	subi	r24, 0xC0	; 192
 418:	80 93 7c 00 	sts	0x007C, r24
 41c:	80 ea       	ldi	r24, 0xA0	; 160
 41e:	9f e0       	ldi	r25, 0x0F	; 15
 420:	01 97       	sbiw	r24, 0x01	; 1
 422:	f1 f7       	brne	.-4      	; 0x420 <analog10+0xa>
 424:	60 e0       	ldi	r22, 0x00	; 0
 426:	70 e0       	ldi	r23, 0x00	; 0
 428:	40 e0       	ldi	r20, 0x00	; 0
 42a:	50 e0       	ldi	r21, 0x00	; 0
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
	{
		tADCH=ADCH;
 42c:	a0 ed       	ldi	r26, 0xD0	; 208
 42e:	b7 e0       	ldi	r27, 0x07	; 7
 430:	20 91 79 00 	lds	r18, 0x0079
		tADCL=ADCL;	
 434:	80 91 78 00 	lds	r24, 0x0078
 438:	fd 01       	movw	r30, r26
 43a:	31 97       	sbiw	r30, 0x01	; 1
 43c:	f1 f7       	brne	.-4      	; 0x43a <analog10+0x24>
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
 43e:	32 2f       	mov	r19, r18
 440:	20 e0       	ldi	r18, 0x00	; 0
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	82 2b       	or	r24, r18
 446:	93 2b       	or	r25, r19
 448:	48 0f       	add	r20, r24
 44a:	59 1f       	adc	r21, r25
	//uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
 44c:	6f 5f       	subi	r22, 0xFF	; 255
 44e:	7f 4f       	sbci	r23, 0xFF	; 255
 450:	6a 30       	cpi	r22, 0x0A	; 10
 452:	71 05       	cpc	r23, r1
 454:	69 f7       	brne	.-38     	; 0x430 <analog10+0x1a>
		tADCL=ADCL;	
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
	}
	valADC=iVal/10;
 456:	ca 01       	movw	r24, r20
 458:	6a e0       	ldi	r22, 0x0A	; 10
 45a:	70 e0       	ldi	r23, 0x00	; 0
 45c:	0e 94 44 04 	call	0x888	; 0x888 <__udivmodhi4>
 460:	70 93 3c 01 	sts	0x013C, r23
 464:	60 93 3b 01 	sts	0x013B, r22
	return ADCH;
 468:	80 91 79 00 	lds	r24, 0x0079
}
 46c:	08 95       	ret

0000046e <__vector_24>:

ISR(ADC_vect){
 46e:	1f 92       	push	r1
 470:	0f 92       	push	r0
 472:	0f b6       	in	r0, 0x3f	; 63
 474:	0f 92       	push	r0
 476:	11 24       	eor	r1, r1
	//valADC=((ADCH<<8) | ADCL);
	//ADC_COMPLETE=true;
}
 478:	0f 90       	pop	r0
 47a:	0f be       	out	0x3f, r0	; 63
 47c:	0f 90       	pop	r0
 47e:	1f 90       	pop	r1
 480:	18 95       	reti

00000482 <DetectTheDot>:

void DetectTheDot(void)
{	
 482:	cf 93       	push	r28
 484:	df 93       	push	r29
	for(iADC=0;iADC<6;iADC++)
 486:	10 92 3d 01 	sts	0x013D, r1
 48a:	c0 e4       	ldi	r28, 0x40	; 64
 48c:	dc e9       	ldi	r29, 0x9C	; 156
 48e:	4e c0       	rjmp	.+156    	; 0x52c <DetectTheDot+0xaa>
	{
		analog10(iADC);
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	0e 94 0b 02 	call	0x416	; 0x416 <analog10>
 496:	ce 01       	movw	r24, r28
 498:	01 97       	sbiw	r24, 0x01	; 1
 49a:	f1 f7       	brne	.-4      	; 0x498 <DetectTheDot+0x16>
		_delay_ms(20);
		if(valADC!=ADC_LastVal[iADC])//If the value has changed
 49c:	80 91 3b 01 	lds	r24, 0x013B
 4a0:	90 91 3c 01 	lds	r25, 0x013C
 4a4:	40 91 3d 01 	lds	r20, 0x013D
 4a8:	e4 2f       	mov	r30, r20
 4aa:	f0 e0       	ldi	r31, 0x00	; 0
 4ac:	ee 0f       	add	r30, r30
 4ae:	ff 1f       	adc	r31, r31
 4b0:	e7 5f       	subi	r30, 0xF7	; 247
 4b2:	fe 4f       	sbci	r31, 0xFE	; 254
 4b4:	20 81       	ld	r18, Z
 4b6:	31 81       	ldd	r19, Z+1	; 0x01
 4b8:	82 17       	cp	r24, r18
 4ba:	93 07       	cpc	r25, r19
 4bc:	91 f1       	breq	.+100    	; 0x522 <DetectTheDot+0xa0>
			This section is used only for debugging the UI.
			Once a change is detected, the analog value is sent directly to the 
			main unit with the message type 'E'. This will be sent to the terminal window
			by the main unit in the format [ADC channel,MSB,LSB].			
			*/
			SendMsgPayLoad[0]=iADC;
 4be:	40 93 01 01 	sts	0x0101, r20
			SendMsgPayLoad[2]=(char)(valADC & 0x00ff);
 4c2:	80 91 3b 01 	lds	r24, 0x013B
 4c6:	90 91 3c 01 	lds	r25, 0x013C
 4ca:	80 93 03 01 	sts	0x0103, r24
			SendMsgPayLoad[1]=(char)((valADC >> 8) & 0x00ff);
 4ce:	80 91 3b 01 	lds	r24, 0x013B
 4d2:	90 91 3c 01 	lds	r25, 0x013C
 4d6:	90 93 02 01 	sts	0x0102, r25
			SendPacket('E',(char*)SendMsgPayLoad,3);
 4da:	85 e4       	ldi	r24, 0x45	; 69
 4dc:	61 e0       	ldi	r22, 0x01	; 1
 4de:	71 e0       	ldi	r23, 0x01	; 1
 4e0:	43 e0       	ldi	r20, 0x03	; 3
 4e2:	50 e0       	ldi	r21, 0x00	; 0
 4e4:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
			/*
			---------------------------------------------------------
			*/
			ADC_LastVal[iADC]=valADC;
 4e8:	e0 91 3d 01 	lds	r30, 0x013D
 4ec:	f0 e0       	ldi	r31, 0x00	; 0
 4ee:	80 91 3b 01 	lds	r24, 0x013B
 4f2:	90 91 3c 01 	lds	r25, 0x013C
 4f6:	ee 0f       	add	r30, r30
 4f8:	ff 1f       	adc	r31, r31
 4fa:	e7 5f       	subi	r30, 0xF7	; 247
 4fc:	fe 4f       	sbci	r31, 0xFE	; 254
 4fe:	91 83       	std	Z+1, r25	; 0x01
 500:	80 83       	st	Z, r24
			if(LED_ONOFF)
 502:	80 91 3a 01 	lds	r24, 0x013A
 506:	88 23       	and	r24, r24
 508:	31 f0       	breq	.+12     	; 0x516 <DetectTheDot+0x94>
			{
				SetStatLED1(false);
 50a:	80 e0       	ldi	r24, 0x00	; 0
 50c:	0e 94 0d 01 	call	0x21a	; 0x21a <SetStatLED1>
				LED_ONOFF=false;
 510:	10 92 3a 01 	sts	0x013A, r1
 514:	06 c0       	rjmp	.+12     	; 0x522 <DetectTheDot+0xa0>
			}else
			{
				SetStatLED1(true);
 516:	81 e0       	ldi	r24, 0x01	; 1
 518:	0e 94 0d 01 	call	0x21a	; 0x21a <SetStatLED1>
				LED_ONOFF=true;
 51c:	81 e0       	ldi	r24, 0x01	; 1
 51e:	80 93 3a 01 	sts	0x013A, r24
	//ADC_COMPLETE=true;
}

void DetectTheDot(void)
{	
	for(iADC=0;iADC<6;iADC++)
 522:	80 91 3d 01 	lds	r24, 0x013D
 526:	8f 5f       	subi	r24, 0xFF	; 255
 528:	80 93 3d 01 	sts	0x013D, r24
 52c:	80 91 3d 01 	lds	r24, 0x013D
 530:	86 30       	cpi	r24, 0x06	; 6
 532:	08 f4       	brcc	.+2      	; 0x536 <DetectTheDot+0xb4>
 534:	ad cf       	rjmp	.-166    	; 0x490 <DetectTheDot+0xe>
				SetStatLED1(true);
				LED_ONOFF=true;
			}
		}
	}
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <init_USART_MCU>:
 * Clock: 8MHz
 * @return Void
 */
void init_USART_MCU(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
 53c:	e1 ec       	ldi	r30, 0xC1	; 193
 53e:	f0 e0       	ldi	r31, 0x00	; 0
 540:	10 82       	st	Z, r1
	UCSR0A = 0x00;
 542:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
 546:	86 e0       	ldi	r24, 0x06	; 6
 548:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x19;
 54c:	89 e1       	ldi	r24, 0x19	; 25
 54e:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate to 19,200 with 8MHz clock
 552:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98; //RXCIE1=1, RXEN1=1, TXEN1=1
 556:	88 e9       	ldi	r24, 0x98	; 152
 558:	80 83       	st	Z, r24
}
 55a:	08 95       	ret

0000055c <__vector_20>:

// TODO: what does this do?
ISR(USART0_RX_vect){
 55c:	1f 92       	push	r1
 55e:	0f 92       	push	r0
 560:	0f b6       	in	r0, 0x3f	; 63
 562:	0f 92       	push	r0
 564:	11 24       	eor	r1, r1
 566:	8f 93       	push	r24
	USART_MCU_Received_Data=UDR0;
 568:	80 91 c6 00 	lds	r24, 0x00C6
 56c:	80 93 07 01 	sts	0x0107, r24
	USART_MCU_DATA_RDY=true;	
 570:	81 e0       	ldi	r24, 0x01	; 1
 572:	80 93 37 01 	sts	0x0137, r24
};
 576:	8f 91       	pop	r24
 578:	0f 90       	pop	r0
 57a:	0f be       	out	0x3f, r0	; 63
 57c:	0f 90       	pop	r0
 57e:	1f 90       	pop	r1
 580:	18 95       	reti

00000582 <USART_PC_ReceiveAction>:
 * @brief receive action sent from PC
 * TODO: why is line commented out / how does it work
 * @return Void
 */
void USART_PC_ReceiveAction(void){
	USART_MCU_DATA_RDY=false;
 582:	10 92 37 01 	sts	0x0137, r1
	//USART_transmitByteToMCU(USART_PC_Received_Data);
}
 586:	08 95       	ret

00000588 <USART_transmitByteToMCU>:
 * UDRE0 : USART Data register empty (bit 5 of UCSR0A
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
 588:	98 2f       	mov	r25, r24
	while ( !(UCSR0A & (1<<UDRE0)) );
 58a:	80 91 c0 00 	lds	r24, 0x00C0
 58e:	85 ff       	sbrs	r24, 5
 590:	fc cf       	rjmp	.-8      	; 0x58a <USART_transmitByteToMCU+0x2>
	UDR0 = bData;
 592:	90 93 c6 00 	sts	0x00C6, r25
}
 596:	08 95       	ret

00000598 <USART_transmitStringToMCUFromFlash>:
 * @brief transmit a string from flash memory
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
 598:	fc 01       	movw	r30, r24
 59a:	07 c0       	rjmp	.+14     	; 0x5aa <USART_transmitStringToMCUFromFlash+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 59c:	80 91 c0 00 	lds	r24, 0x00C0
 5a0:	85 ff       	sbrs	r24, 5
 5a2:	fc cf       	rjmp	.-8      	; 0x59c <USART_transmitStringToMCUFromFlash+0x4>
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
 5a4:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 5a6:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
 5aa:	94 91       	lpm	r25, Z+
 5ac:	99 23       	and	r25, r25
 5ae:	b1 f7       	brne	.-20     	; 0x59c <USART_transmitStringToMCUFromFlash+0x4>
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
}
 5b0:	08 95       	ret

000005b2 <USART_transmitStringToMCU>:
 * @brief transmit a string to the data register
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
 5b2:	fc 01       	movw	r30, r24
 5b4:	07 c0       	rjmp	.+14     	; 0x5c4 <USART_transmitStringToMCU+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 5b6:	80 91 c0 00 	lds	r24, 0x00C0
 5ba:	85 ff       	sbrs	r24, 5
 5bc:	fc cf       	rjmp	.-8      	; 0x5b6 <USART_transmitStringToMCU+0x4>
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
   USART_transmitByteToMCU(*strData++);
 5be:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 5c0:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
 5c4:	90 81       	ld	r25, Z
 5c6:	99 23       	and	r25, r25
 5c8:	b1 f7       	brne	.-20     	; 0x5b6 <USART_transmitStringToMCU+0x4>
   USART_transmitByteToMCU(*strData++);
}
 5ca:	08 95       	ret

000005cc <initTimer>:
 * @brief Initialize the timer
 * @return Void
 */
void initTimer(void)
{
	TMR1_INT=false;
 5cc:	10 92 06 01 	sts	0x0106, r1
	TCCR1A=0x00;
 5d0:	10 92 80 00 	sts	0x0080, r1
 	TCCR1B=0x0D;
 5d4:	8d e0       	ldi	r24, 0x0D	; 13
 5d6:	80 93 81 00 	sts	0x0081, r24
  	OCR1A=780; //1s interval
 5da:	8c e0       	ldi	r24, 0x0C	; 12
 5dc:	93 e0       	ldi	r25, 0x03	; 3
 5de:	90 93 89 00 	sts	0x0089, r25
 5e2:	80 93 88 00 	sts	0x0088, r24
 	TIMSK1 |= (1<<OCIE1A); //Enable interrupt
 5e6:	ef e6       	ldi	r30, 0x6F	; 111
 5e8:	f0 e0       	ldi	r31, 0x00	; 0
 5ea:	80 81       	ld	r24, Z
 5ec:	82 60       	ori	r24, 0x02	; 2
 5ee:	80 83       	st	Z, r24
  
	TmrCntADC=0;
 5f0:	10 92 54 01 	sts	0x0154, r1
 5f4:	10 92 53 01 	sts	0x0153, r1
}
 5f8:	08 95       	ret

000005fa <TimerRoutine>:
	SetStatLED2(false);
};

void TimerRoutine(void)
{
	TMR1_INT=false;
 5fa:	10 92 06 01 	sts	0x0106, r1
	{
		DetectTheDot();
		ProcessTheDot();
		TmrCntADC=0;
	}*/
	SetStatLED2(false);
 5fe:	80 e0       	ldi	r24, 0x00	; 0
 600:	0e 94 13 01 	call	0x226	; 0x226 <SetStatLED2>
}
 604:	08 95       	ret

00000606 <__vector_13>:
}

/**
 * @brief interrupt handler for TIMER1_COMPA_vect
 */
ISR(TIMER1_COMPA_vect){
 606:	1f 92       	push	r1
 608:	0f 92       	push	r0
 60a:	0f b6       	in	r0, 0x3f	; 63
 60c:	0f 92       	push	r0
 60e:	0b b6       	in	r0, 0x3b	; 59
 610:	0f 92       	push	r0
 612:	11 24       	eor	r1, r1
 614:	2f 93       	push	r18
 616:	3f 93       	push	r19
 618:	4f 93       	push	r20
 61a:	5f 93       	push	r21
 61c:	6f 93       	push	r22
 61e:	7f 93       	push	r23
 620:	8f 93       	push	r24
 622:	9f 93       	push	r25
 624:	af 93       	push	r26
 626:	bf 93       	push	r27
 628:	ef 93       	push	r30
 62a:	ff 93       	push	r31
	TMR1_INT=true;
 62c:	81 e0       	ldi	r24, 0x01	; 1
 62e:	80 93 06 01 	sts	0x0106, r24
	SetStatLED2(false);
 632:	80 e0       	ldi	r24, 0x00	; 0
 634:	0e 94 13 01 	call	0x226	; 0x226 <SetStatLED2>
};
 638:	ff 91       	pop	r31
 63a:	ef 91       	pop	r30
 63c:	bf 91       	pop	r27
 63e:	af 91       	pop	r26
 640:	9f 91       	pop	r25
 642:	8f 91       	pop	r24
 644:	7f 91       	pop	r23
 646:	6f 91       	pop	r22
 648:	5f 91       	pop	r21
 64a:	4f 91       	pop	r20
 64c:	3f 91       	pop	r19
 64e:	2f 91       	pop	r18
 650:	0f 90       	pop	r0
 652:	0b be       	out	0x3b, r0	; 59
 654:	0f 90       	pop	r0
 656:	0f be       	out	0x3f, r0	; 63
 658:	0f 90       	pop	r0
 65a:	1f 90       	pop	r1
 65c:	18 95       	reti

0000065e <Calculate_CRC>:
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 65e:	0f 93       	push	r16
 660:	1f 93       	push	r17
 662:	cf 93       	push	r28
 664:	df 93       	push	r29
 666:	fc 01       	movw	r30, r24
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
 668:	b2 81       	ldd	r27, Z+2	; 0x02
	uint16_t chksum=0;
	pstrMsg+=3;
 66a:	8c 01       	movw	r16, r24
 66c:	0d 5f       	subi	r16, 0xFD	; 253
 66e:	1f 4f       	sbci	r17, 0xFF	; 255
 670:	60 e0       	ldi	r22, 0x00	; 0
 672:	70 e0       	ldi	r23, 0x00	; 0
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 674:	b5 50       	subi	r27, 0x05	; 5
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 676:	ab 2f       	mov	r26, r27
 678:	a6 95       	lsr	r26
 67a:	ca 2f       	mov	r28, r26
 67c:	d0 e0       	ldi	r29, 0x00	; 0
 67e:	ae 01       	movw	r20, r28
 680:	4f 5f       	subi	r20, 0xFF	; 255
 682:	5f 4f       	sbci	r21, 0xFF	; 255
 684:	44 0f       	add	r20, r20
 686:	55 1f       	adc	r21, r21
 688:	4e 0f       	add	r20, r30
 68a:	5f 1f       	adc	r21, r31
 68c:	08 c0       	rjmp	.+16     	; 0x69e <Calculate_CRC+0x40>
	{
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
 68e:	31 81       	ldd	r19, Z+1	; 0x01
 690:	20 e0       	ldi	r18, 0x00	; 0
 692:	82 81       	ldd	r24, Z+2	; 0x02
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	82 2b       	or	r24, r18
 698:	93 2b       	or	r25, r19
 69a:	68 0f       	add	r22, r24
 69c:	79 1f       	adc	r23, r25
 69e:	32 96       	adiw	r30, 0x02	; 2
uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 6a0:	e4 17       	cp	r30, r20
 6a2:	f5 07       	cpc	r31, r21
 6a4:	a1 f7       	brne	.-24     	; 0x68e <Calculate_CRC+0x30>
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 6a6:	aa 0f       	add	r26, r26
 6a8:	fe 01       	movw	r30, r28
 6aa:	ee 0f       	add	r30, r30
 6ac:	ff 1f       	adc	r31, r31
 6ae:	e0 0f       	add	r30, r16
 6b0:	f1 1f       	adc	r31, r17
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
		chksum = chksum & 0xffff;
		msglen-=2;
		pstrMsg+=2;
	}
	if(msglen>0) //If the packet size is odd numbered
 6b2:	ba 17       	cp	r27, r26
 6b4:	21 f0       	breq	.+8      	; 0x6be <Calculate_CRC+0x60>
	{
		chksum = chksum^ (int)*(pstrMsg++);
 6b6:	80 81       	ld	r24, Z
 6b8:	90 e0       	ldi	r25, 0x00	; 0
 6ba:	68 27       	eor	r22, r24
 6bc:	79 27       	eor	r23, r25
	}
	return(chksum);
}
 6be:	cb 01       	movw	r24, r22
 6c0:	df 91       	pop	r29
 6c2:	cf 91       	pop	r28
 6c4:	1f 91       	pop	r17
 6c6:	0f 91       	pop	r16
 6c8:	08 95       	ret

000006ca <MCU_PKT_CompilePacket>:

bool MCU_PKT_CompilePacket(char cmd, char* pl, int plLen)
{
 6ca:	cf 93       	push	r28
 6cc:	df 93       	push	r29
 6ce:	98 2f       	mov	r25, r24
 6d0:	db 01       	movw	r26, r22
 6d2:	ea 01       	movw	r28, r20
	// [U][I][msglen][msg_number][msgtype][payload][CRC1][CRC2]
	uint16_t chksum;
	//Header always contain the 0xFA and 0xFB
	MCU_Packet[0]='U';
 6d4:	85 e5       	ldi	r24, 0x55	; 85
 6d6:	80 93 1f 01 	sts	0x011F, r24
	MCU_Packet[1]='I';
 6da:	89 e4       	ldi	r24, 0x49	; 73
 6dc:	80 93 20 01 	sts	0x0120, r24
	iPktSize=plLen+7;
 6e0:	27 96       	adiw	r28, 0x07	; 7
 6e2:	d0 93 18 01 	sts	0x0118, r29
 6e6:	c0 93 17 01 	sts	0x0117, r28
 6ea:	27 97       	sbiw	r28, 0x07	; 7
	if ( plLen+7 > 20 ) //SABT can handle packets upto 20 bytes 
 6ec:	ce 30       	cpi	r28, 0x0E	; 14
 6ee:	d1 05       	cpc	r29, r1
 6f0:	14 f0       	brlt	.+4      	; 0x6f6 <MCU_PKT_CompilePacket+0x2c>
 6f2:	80 e0       	ldi	r24, 0x00	; 0
 6f4:	22 c0       	rjmp	.+68     	; 0x73a <MCU_PKT_CompilePacket+0x70>
	{
		return(false);
	}
	MCU_Packet[2] = plLen+7;
 6f6:	9e 01       	movw	r18, r28
 6f8:	29 5f       	subi	r18, 0xF9	; 249
 6fa:	20 93 21 01 	sts	0x0121, r18
	MCU_Packet[3] = 2;	
 6fe:	82 e0       	ldi	r24, 0x02	; 2
 700:	80 93 22 01 	sts	0x0122, r24
	MCU_Packet[4] = cmd;	
 704:	90 93 23 01 	sts	0x0123, r25
 708:	20 e0       	ldi	r18, 0x00	; 0
 70a:	30 e0       	ldi	r19, 0x00	; 0
 70c:	07 c0       	rjmp	.+14     	; 0x71c <MCU_PKT_CompilePacket+0x52>
	int i=0;
	for(i=0;i<plLen;i++)
	{
		MCU_Packet[5+i]=*(pl++);
 70e:	8d 91       	ld	r24, X+
 710:	f9 01       	movw	r30, r18
 712:	ec 5d       	subi	r30, 0xDC	; 220
 714:	fe 4f       	sbci	r31, 0xFE	; 254
 716:	80 83       	st	Z, r24
	}
	MCU_Packet[2] = plLen+7;
	MCU_Packet[3] = 2;	
	MCU_Packet[4] = cmd;	
	int i=0;
	for(i=0;i<plLen;i++)
 718:	2f 5f       	subi	r18, 0xFF	; 255
 71a:	3f 4f       	sbci	r19, 0xFF	; 255
 71c:	2c 17       	cp	r18, r28
 71e:	3d 07       	cpc	r19, r29
 720:	b4 f3       	brlt	.-20     	; 0x70e <MCU_PKT_CompilePacket+0x44>
	{
		MCU_Packet[5+i]=*(pl++);
	}
	//memcpy( &MCU_Packet[5], pl, plLen);
	chksum = Calculate_CRC((unsigned char*)MCU_Packet);
 722:	8f e1       	ldi	r24, 0x1F	; 31
 724:	91 e0       	ldi	r25, 0x01	; 1
 726:	0e 94 2f 03 	call	0x65e	; 0x65e <Calculate_CRC>
	MCU_Packet[plLen+5] = chksum >> 8;
 72a:	fe 01       	movw	r30, r28
 72c:	ec 5d       	subi	r30, 0xDC	; 220
 72e:	fe 4f       	sbci	r31, 0xFE	; 254
 730:	90 83       	st	Z, r25
	MCU_Packet[plLen+6] = chksum & 0xFF;	
 732:	cb 5d       	subi	r28, 0xDB	; 219
 734:	de 4f       	sbci	r29, 0xFE	; 254
 736:	88 83       	st	Y, r24
 738:	81 e0       	ldi	r24, 0x01	; 1
	return(true);
}
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	08 95       	ret

00000740 <SendPacket>:

void SendPacket(char cmd, char* payLoad, int plLen)
{
 740:	cf 93       	push	r28
 742:	df 93       	push	r29
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
 744:	0e 94 65 03 	call	0x6ca	; 0x6ca <MCU_PKT_CompilePacket>
 748:	88 23       	and	r24, r24
 74a:	89 f0       	breq	.+34     	; 0x76e <SendPacket+0x2e>
 74c:	c0 e0       	ldi	r28, 0x00	; 0
 74e:	d0 e0       	ldi	r29, 0x00	; 0
 750:	07 c0       	rjmp	.+14     	; 0x760 <SendPacket+0x20>
	{
		for(i=0;i<iPktSize;i++)
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
 752:	fe 01       	movw	r30, r28
 754:	e1 5e       	subi	r30, 0xE1	; 225
 756:	fe 4f       	sbci	r31, 0xFE	; 254
 758:	80 81       	ld	r24, Z
 75a:	0e 94 c4 02 	call	0x588	; 0x588 <USART_transmitByteToMCU>
void SendPacket(char cmd, char* payLoad, int plLen)
{
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
	{
		for(i=0;i<iPktSize;i++)
 75e:	21 96       	adiw	r28, 0x01	; 1
 760:	80 91 17 01 	lds	r24, 0x0117
 764:	90 91 18 01 	lds	r25, 0x0118
 768:	c8 17       	cp	r28, r24
 76a:	d9 07       	cpc	r29, r25
 76c:	94 f3       	brlt	.-28     	; 0x752 <SendPacket+0x12>
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
		}
	}	

}
 76e:	df 91       	pop	r29
 770:	cf 91       	pop	r28
 772:	08 95       	ret

00000774 <ResetCellState>:
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 774:	10 92 19 01 	sts	0x0119, r1
 778:	10 92 1a 01 	sts	0x011A, r1
 77c:	10 92 1b 01 	sts	0x011B, r1
 780:	10 92 1c 01 	sts	0x011C, r1
 784:	10 92 1d 01 	sts	0x011D, r1
 788:	10 92 1e 01 	sts	0x011E, r1
	}
	PI_LastDotPressed=0;
 78c:	10 92 56 01 	sts	0x0156, r1
}
 790:	08 95       	ret

00000792 <CaptureCellValue>:
	}
}


void CaptureCellValue(void)
{
 792:	20 e0       	ldi	r18, 0x00	; 0
 794:	30 e0       	ldi	r19, 0x00	; 0
 796:	40 e0       	ldi	r20, 0x00	; 0
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
 798:	61 e0       	ldi	r22, 0x01	; 1
 79a:	70 e0       	ldi	r23, 0x00	; 0
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
 79c:	f9 01       	movw	r30, r18
 79e:	e7 5e       	subi	r30, 0xE7	; 231
 7a0:	fe 4f       	sbci	r31, 0xFE	; 254
 7a2:	80 81       	ld	r24, Z
 7a4:	88 23       	and	r24, r24
 7a6:	41 f0       	breq	.+16     	; 0x7b8 <CaptureCellValue+0x26>
		{
			ProcessedCellValue |= _BV(i);
 7a8:	cb 01       	movw	r24, r22
 7aa:	02 2e       	mov	r0, r18
 7ac:	02 c0       	rjmp	.+4      	; 0x7b2 <CaptureCellValue+0x20>
 7ae:	88 0f       	add	r24, r24
 7b0:	99 1f       	adc	r25, r25
 7b2:	0a 94       	dec	r0
 7b4:	e2 f7       	brpl	.-8      	; 0x7ae <CaptureCellValue+0x1c>
 7b6:	48 2b       	or	r20, r24
	/*
	This section process the stored dot values and
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
 7b8:	2f 5f       	subi	r18, 0xFF	; 255
 7ba:	3f 4f       	sbci	r19, 0xFF	; 255
 7bc:	26 30       	cpi	r18, 0x06	; 6
 7be:	31 05       	cpc	r19, r1
 7c0:	69 f7       	brne	.-38     	; 0x79c <CaptureCellValue+0xa>
 7c2:	40 93 55 01 	sts	0x0155, r20
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
		}
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
 7c6:	40 93 01 01 	sts	0x0101, r20
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
 7ca:	81 e0       	ldi	r24, 0x01	; 1
 7cc:	80 93 02 01 	sts	0x0102, r24
	SendPacket('B',(char*)SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
 7d0:	82 e4       	ldi	r24, 0x42	; 66
 7d2:	61 e0       	ldi	r22, 0x01	; 1
 7d4:	71 e0       	ldi	r23, 0x01	; 1
 7d6:	42 e0       	ldi	r20, 0x02	; 2
 7d8:	50 e0       	ldi	r21, 0x00	; 0
 7da:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 7de:	10 92 19 01 	sts	0x0119, r1
 7e2:	10 92 1a 01 	sts	0x011A, r1
 7e6:	10 92 1b 01 	sts	0x011B, r1
 7ea:	10 92 1c 01 	sts	0x011C, r1
 7ee:	10 92 1d 01 	sts	0x011D, r1
 7f2:	10 92 1e 01 	sts	0x011E, r1
	}
	PI_LastDotPressed=0;
 7f6:	10 92 56 01 	sts	0x0156, r1
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
	SendPacket('B',(char*)SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
	ResetCellState();						//Reset the cell state so that new letter can start
}
 7fa:	08 95       	ret

000007fc <ProcessTheDot>:
void ProcessTheDot(void)
{
	uint8_t TempDot=0;
//	uint8_t PI_ThisDot;
	bool NewDotDetected=false;
	if(!(PINC & (1<<UI_BR1))) //Dot1
 7fc:	34 99       	sbic	0x06, 4	; 6
 7fe:	03 c0       	rjmp	.+6      	; 0x806 <ProcessTheDot+0xa>
 800:	91 e0       	ldi	r25, 0x01	; 1
 802:	81 e0       	ldi	r24, 0x01	; 1
 804:	02 c0       	rjmp	.+4      	; 0x80a <ProcessTheDot+0xe>
 806:	90 e0       	ldi	r25, 0x00	; 0
 808:	80 e0       	ldi	r24, 0x00	; 0
	{
		NewDotDetected=true;
		TempDot=1;
	}
	if(!(PINC & (1<<UI_BR2))) //Dot1
 80a:	31 99       	sbic	0x06, 1	; 6
 80c:	02 c0       	rjmp	.+4      	; 0x812 <ProcessTheDot+0x16>
 80e:	92 e0       	ldi	r25, 0x02	; 2
 810:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=2;
	}
	if(!(PINC & (1<<UI_BR3))) //Dot1
 812:	35 99       	sbic	0x06, 5	; 6
 814:	02 c0       	rjmp	.+4      	; 0x81a <ProcessTheDot+0x1e>
 816:	93 e0       	ldi	r25, 0x03	; 3
 818:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=3;
	}
	if(!(PINC & (1<<UI_BR4))) //Dot1
 81a:	32 99       	sbic	0x06, 2	; 6
 81c:	02 c0       	rjmp	.+4      	; 0x822 <ProcessTheDot+0x26>
 81e:	94 e0       	ldi	r25, 0x04	; 4
 820:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=4;
	}
	if(!(PINC & (1<<UI_BR5))) //Dot1
 822:	33 99       	sbic	0x06, 3	; 6
 824:	02 c0       	rjmp	.+4      	; 0x82a <ProcessTheDot+0x2e>
 826:	95 e0       	ldi	r25, 0x05	; 5
 828:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=5;
	}
	if(!(PINC & (1<<UI_BR6))) //Dot1
 82a:	30 99       	sbic	0x06, 0	; 6
 82c:	02 c0       	rjmp	.+4      	; 0x832 <ProcessTheDot+0x36>
 82e:	96 e0       	ldi	r25, 0x06	; 6
 830:	02 c0       	rjmp	.+4      	; 0x836 <ProcessTheDot+0x3a>
	{
		NewDotDetected=true;
		TempDot=6;
	}

	if(NewDotDetected)
 832:	88 23       	and	r24, r24
 834:	41 f1       	breq	.+80     	; 0x886 <ProcessTheDot+0x8a>
	{
		if(InterfaceType==1)
 836:	80 91 15 01 	lds	r24, 0x0115
 83a:	81 30       	cpi	r24, 0x01	; 1
 83c:	49 f0       	breq	.+18     	; 0x850 <ProcessTheDot+0x54>
		{
			//OK this is the default			
		}else if(InterfaceType==2)
 83e:	80 91 15 01 	lds	r24, 0x0115
 842:	82 30       	cpi	r24, 0x02	; 2
 844:	29 f4       	brne	.+10     	; 0x850 <ProcessTheDot+0x54>
		{
			//OK Flip the pattern
			if(TempDot>3) TempDot-=3;
 846:	94 30       	cpi	r25, 0x04	; 4
 848:	10 f0       	brcs	.+4      	; 0x84e <ProcessTheDot+0x52>
 84a:	93 50       	subi	r25, 0x03	; 3
 84c:	01 c0       	rjmp	.+2      	; 0x850 <ProcessTheDot+0x54>
			else TempDot+=3;
 84e:	9d 5f       	subi	r25, 0xFD	; 253
		}
		if(PI_LastDotPressed==TempDot) return;
 850:	80 91 56 01 	lds	r24, 0x0156
 854:	89 17       	cp	r24, r25
 856:	b9 f0       	breq	.+46     	; 0x886 <ProcessTheDot+0x8a>
		PI_LastDotPressed=TempDot;
 858:	90 93 56 01 	sts	0x0156, r25
		DotsPressed[TempDot-1]=true;
 85c:	e9 2f       	mov	r30, r25
 85e:	f0 e0       	ldi	r31, 0x00	; 0
 860:	e8 5e       	subi	r30, 0xE8	; 232
 862:	fe 4f       	sbci	r31, 0xFE	; 254
 864:	81 e0       	ldi	r24, 0x01	; 1
 866:	80 83       	st	Z, r24
		SendMsgPayLoad[0]=0x30+PI_LastDotPressed;
 868:	90 5d       	subi	r25, 0xD0	; 208
 86a:	90 93 01 01 	sts	0x0101, r25
		SendMsgPayLoad[1]=0x31;
 86e:	81 e3       	ldi	r24, 0x31	; 49
 870:	80 93 02 01 	sts	0x0102, r24
		SendMsgPayLoad[2]=0x31;
 874:	80 93 03 01 	sts	0x0103, r24
    	SendPacket('A',(char*)SendMsgPayLoad,3);
 878:	81 e4       	ldi	r24, 0x41	; 65
 87a:	61 e0       	ldi	r22, 0x01	; 1
 87c:	71 e0       	ldi	r23, 0x01	; 1
 87e:	43 e0       	ldi	r20, 0x03	; 3
 880:	50 e0       	ldi	r21, 0x00	; 0
 882:	0e 94 a0 03 	call	0x740	; 0x740 <SendPacket>
 886:	08 95       	ret

00000888 <__udivmodhi4>:
 888:	aa 1b       	sub	r26, r26
 88a:	bb 1b       	sub	r27, r27
 88c:	51 e1       	ldi	r21, 0x11	; 17
 88e:	07 c0       	rjmp	.+14     	; 0x89e <__udivmodhi4_ep>

00000890 <__udivmodhi4_loop>:
 890:	aa 1f       	adc	r26, r26
 892:	bb 1f       	adc	r27, r27
 894:	a6 17       	cp	r26, r22
 896:	b7 07       	cpc	r27, r23
 898:	10 f0       	brcs	.+4      	; 0x89e <__udivmodhi4_ep>
 89a:	a6 1b       	sub	r26, r22
 89c:	b7 0b       	sbc	r27, r23

0000089e <__udivmodhi4_ep>:
 89e:	88 1f       	adc	r24, r24
 8a0:	99 1f       	adc	r25, r25
 8a2:	5a 95       	dec	r21
 8a4:	a9 f7       	brne	.-22     	; 0x890 <__udivmodhi4_loop>
 8a6:	80 95       	com	r24
 8a8:	90 95       	com	r25
 8aa:	bc 01       	movw	r22, r24
 8ac:	cd 01       	movw	r24, r26
 8ae:	08 95       	ret

000008b0 <_exit>:
 8b0:	f8 94       	cli

000008b2 <__stop_program>:
 8b2:	ff cf       	rjmp	.-2      	; 0x8b2 <__stop_program>
