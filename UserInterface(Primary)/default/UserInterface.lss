
UserInterface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  00000888  0000091c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000888  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000057  00800112  00800112  0000092e  2**0
                  ALLOC
  3 .debug_aranges 000000e0  00000000  00000000  0000092e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000b1d  00000000  00000000  00000a0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001777  00000000  00000000  0000152b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000718  00000000  00000000  00002ca2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000010bf  00000000  00000000  000033ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002a0  00000000  00000000  0000447c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000052e  00000000  00000000  0000471c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000040a  00000000  00000000  00004c4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000108  00000000  00000000  00005054  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 ea 02 	jmp	0x5d4	; 0x5d4 <__vector_13>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 24 02 	jmp	0x448	; 0x448 <__vector_24>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e8 e8       	ldi	r30, 0x88	; 136
  a0:	f8 e0       	ldi	r31, 0x08	; 8
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 31       	cpi	r26, 0x12	; 18
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a2 e1       	ldi	r26, 0x12	; 18
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a9 36       	cpi	r26, 0x69	; 105
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 72 00 	call	0xe4	; 0xe4 <main>
  c6:	0c 94 42 04 	jmp	0x884	; 0x884 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <InitializeUI>:
}

void InitializeUI(void)
{
	//Initialize the Serial comm with the main module
	init_USART_MCU();
  ce:	0e 94 8b 02 	call	0x516	; 0x516 <init_USART_MCU>
	//Initialize the analog ports
	//InitializeAnalogPorts();
	//Initialize the digital input/output pins
	Initialize_Digital_IO();
  d2:	0e 94 7e 00 	call	0xfc	; 0xfc <Initialize_Digital_IO>
	// Initialize the timer
	initTimer();
  d6:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <initTimer>
	// Enable interrupts
	sei();
  da:	78 94       	sei
	InterfaceType=1;
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	80 93 27 01 	sts	0x0127, r24
}
  e2:	08 95       	ret

000000e4 <main>:

void InitializeUI(void);

int main(void)
{
	InitializeUI();
  e4:	0e 94 67 00 	call	0xce	; 0xce <InitializeUI>
	SendMsgPayLoad[0]=0x01;
  e8:	81 e0       	ldi	r24, 0x01	; 1
  ea:	80 93 13 01 	sts	0x0113, r24
 	{
		// TODO:  remove these

		//SetStatLED1(true);
		//SetStatLED2(true); 
		if(TMR1_INT)
  ee:	80 91 18 01 	lds	r24, 0x0118
  f2:	88 23       	and	r24, r24
  f4:	e1 f3       	breq	.-8      	; 0xee <main+0xa>
		{
			TimerRoutine();
  f6:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <TimerRoutine>
  fa:	f9 cf       	rjmp	.-14     	; 0xee <main+0xa>

000000fc <Initialize_Digital_IO>:
#include "GlobalsUI.h"

void Initialize_Digital_IO(void)
{
	Enter1State=0;
  fc:	10 92 48 01 	sts	0x0148, r1
	Enter2State=0;
 100:	10 92 12 01 	sts	0x0112, r1
	Mode1State=0;
 104:	10 92 45 01 	sts	0x0145, r1
	Mode2State=0;
 108:	10 92 46 01 	sts	0x0146, r1
	VolUpState=0;
 10c:	10 92 47 01 	sts	0x0147, r1
	VolDownState=0;
 110:	10 92 28 01 	sts	0x0128, r1
		
	DDRC &= ~_BV(UI_BR1);	
 114:	3c 98       	cbi	0x07, 4	; 7
	DDRC &= ~_BV(UI_BR2);
 116:	39 98       	cbi	0x07, 1	; 7
	DDRC &= ~_BV(UI_BR3);
 118:	3d 98       	cbi	0x07, 5	; 7
	DDRC &= ~_BV(UI_BR4);
 11a:	3a 98       	cbi	0x07, 2	; 7
	DDRC &= ~_BV(UI_BR5);
 11c:	3b 98       	cbi	0x07, 3	; 7
	DDRC &= ~_BV(UI_BR6);
 11e:	38 98       	cbi	0x07, 0	; 7

	DDRB &= ~_BV(UI_ENTER1);
 120:	27 98       	cbi	0x04, 7	; 4
	DDRB &= ~_BV(UI_ENTER2);
 122:	26 98       	cbi	0x04, 6	; 4
	DDRB &= ~_BV(UI_MODE1);
 124:	21 98       	cbi	0x04, 1	; 4
	DDRB &= ~_BV(UI_MODE2);
 126:	20 98       	cbi	0x04, 0	; 4

	DDRD &= ~_BV(UI_VOLUP);
 128:	53 98       	cbi	0x0a, 3	; 10
	DDRD &= ~_BV(UI_VOLDOWN);
 12a:	52 98       	cbi	0x0a, 2	; 10
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
 12c:	8a b1       	in	r24, 0x0a	; 10
 12e:	80 6c       	ori	r24, 0xC0	; 192
 130:	8a b9       	out	0x0a, r24	; 10

void SetStatLED1(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT1);
 132:	5e 98       	cbi	0x0b, 6	; 11

void SetStatLED2(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT2);
 134:	5f 98       	cbi	0x0b, 7	; 11
	DDRD &= ~_BV(UI_VOLDOWN);
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
	//switch off stat LEDs
	SetStatLED1(false);
	SetStatLED2(false); 
}
 136:	08 95       	ret

00000138 <CheckCommandButtons>:

void CheckCommandButtons(void)
{
	if(!(PINB & (1<<UI_ENTER1)))
 138:	1f 99       	sbic	0x03, 7	; 3
 13a:	0a c0       	rjmp	.+20     	; 0x150 <CheckCommandButtons+0x18>
	{
		if(Enter1State==0)
 13c:	80 91 48 01 	lds	r24, 0x0148
 140:	88 23       	and	r24, r24
 142:	41 f4       	brne	.+16     	; 0x154 <CheckCommandButtons+0x1c>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER1)))
 144:	1f 99       	sbic	0x03, 7	; 3
 146:	06 c0       	rjmp	.+12     	; 0x154 <CheckCommandButtons+0x1c>
			{
				Enter1State=1;
 148:	81 e0       	ldi	r24, 0x01	; 1
 14a:	80 93 48 01 	sts	0x0148, r24
 14e:	02 c0       	rjmp	.+4      	; 0x154 <CheckCommandButtons+0x1c>
			}
		}
	}
	else
	{
		Enter1State=0;
 150:	10 92 48 01 	sts	0x0148, r1
	}

	if(!(PINB & (1<<UI_ENTER2)))
 154:	1e 99       	sbic	0x03, 6	; 3
 156:	13 c0       	rjmp	.+38     	; 0x17e <CheckCommandButtons+0x46>
	{
		if(Enter2State==0)
 158:	80 91 12 01 	lds	r24, 0x0112
 15c:	88 23       	and	r24, r24
 15e:	89 f4       	brne	.+34     	; 0x182 <CheckCommandButtons+0x4a>
 160:	88 ee       	ldi	r24, 0xE8	; 232
 162:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 164:	28 ec       	ldi	r18, 0xC8	; 200
 166:	30 e0       	ldi	r19, 0x00	; 0
 168:	f9 01       	movw	r30, r18
 16a:	31 97       	sbiw	r30, 0x01	; 1
 16c:	f1 f7       	brne	.-4      	; 0x16a <CheckCommandButtons+0x32>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 16e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 170:	d9 f7       	brne	.-10     	; 0x168 <CheckCommandButtons+0x30>
		{
			_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER2)))
 172:	1e 99       	sbic	0x03, 6	; 3
 174:	06 c0       	rjmp	.+12     	; 0x182 <CheckCommandButtons+0x4a>
			{
				Enter2State=1;
 176:	81 e0       	ldi	r24, 0x01	; 1
 178:	80 93 12 01 	sts	0x0112, r24
 17c:	02 c0       	rjmp	.+4      	; 0x182 <CheckCommandButtons+0x4a>
			}
		}
	}
	else
	{
		Enter2State=0;
 17e:	10 92 12 01 	sts	0x0112, r1
	}

	if(!(PINB & (1<<UI_MODE1)))
 182:	19 99       	sbic	0x03, 1	; 3
 184:	0a c0       	rjmp	.+20     	; 0x19a <CheckCommandButtons+0x62>
	{
		if(Mode1State==0)
 186:	80 91 45 01 	lds	r24, 0x0145
 18a:	88 23       	and	r24, r24
 18c:	41 f4       	brne	.+16     	; 0x19e <CheckCommandButtons+0x66>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE1)))
 18e:	19 99       	sbic	0x03, 1	; 3
 190:	06 c0       	rjmp	.+12     	; 0x19e <CheckCommandButtons+0x66>
			{
				Mode1State=1;
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	80 93 45 01 	sts	0x0145, r24
 198:	02 c0       	rjmp	.+4      	; 0x19e <CheckCommandButtons+0x66>
			}
		}
	}
	else
	{
		Mode1State=0;
 19a:	10 92 45 01 	sts	0x0145, r1
	}

	if(!(PINB & (1<<UI_MODE2)))
 19e:	18 99       	sbic	0x03, 0	; 3
 1a0:	0a c0       	rjmp	.+20     	; 0x1b6 <CheckCommandButtons+0x7e>
	{
		if(Mode2State==0)
 1a2:	80 91 46 01 	lds	r24, 0x0146
 1a6:	88 23       	and	r24, r24
 1a8:	41 f4       	brne	.+16     	; 0x1ba <CheckCommandButtons+0x82>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE2)))
 1aa:	18 99       	sbic	0x03, 0	; 3
 1ac:	06 c0       	rjmp	.+12     	; 0x1ba <CheckCommandButtons+0x82>
			{
				Mode2State=1;
 1ae:	81 e0       	ldi	r24, 0x01	; 1
 1b0:	80 93 46 01 	sts	0x0146, r24
 1b4:	02 c0       	rjmp	.+4      	; 0x1ba <CheckCommandButtons+0x82>
			}
		}
	}
	else
	{
		Mode2State=0;
 1b6:	10 92 46 01 	sts	0x0146, r1
	}

	if(!(PIND & (1<<UI_VOLUP)))
 1ba:	4b 99       	sbic	0x09, 3	; 9
 1bc:	0a c0       	rjmp	.+20     	; 0x1d2 <CheckCommandButtons+0x9a>
	{
		if(VolUpState==0)
 1be:	80 91 47 01 	lds	r24, 0x0147
 1c2:	88 23       	and	r24, r24
 1c4:	41 f4       	brne	.+16     	; 0x1d6 <CheckCommandButtons+0x9e>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLUP)))
 1c6:	4b 99       	sbic	0x09, 3	; 9
 1c8:	06 c0       	rjmp	.+12     	; 0x1d6 <CheckCommandButtons+0x9e>
			{
				VolUpState=1;
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 47 01 	sts	0x0147, r24
 1d0:	02 c0       	rjmp	.+4      	; 0x1d6 <CheckCommandButtons+0x9e>
			}
		}
	}
	else
	{
		VolUpState=0;
 1d2:	10 92 47 01 	sts	0x0147, r1
	}

	if(!(PIND & (1<<UI_VOLDOWN)))
 1d6:	4a 99       	sbic	0x09, 2	; 9
 1d8:	0a c0       	rjmp	.+20     	; 0x1ee <CheckCommandButtons+0xb6>
	{
		if(VolDownState==0)
 1da:	80 91 28 01 	lds	r24, 0x0128
 1de:	88 23       	and	r24, r24
 1e0:	41 f4       	brne	.+16     	; 0x1f2 <CheckCommandButtons+0xba>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLDOWN)))
 1e2:	4a 99       	sbic	0x09, 2	; 9
 1e4:	06 c0       	rjmp	.+12     	; 0x1f2 <CheckCommandButtons+0xba>
			{
				VolDownState=1;
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	80 93 28 01 	sts	0x0128, r24
 1ec:	08 95       	ret
			}
		}
	}
	else
	{
		VolDownState=0;
 1ee:	10 92 28 01 	sts	0x0128, r1
 1f2:	08 95       	ret

000001f4 <SetStatLED1>:
}
*/

void SetStatLED1(bool bState)
{
	if(!bState)
 1f4:	88 23       	and	r24, r24
 1f6:	11 f4       	brne	.+4      	; 0x1fc <SetStatLED1+0x8>
	{
		PORTD &= ~_BV(UI_STAT1);
 1f8:	5e 98       	cbi	0x0b, 6	; 11
 1fa:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 1fc:	5e 9a       	sbi	0x0b, 6	; 11
 1fe:	08 95       	ret

00000200 <SetStatLED2>:
	}
}

void SetStatLED2(bool bState)
{
	if(!bState)
 200:	88 23       	and	r24, r24
 202:	11 f4       	brne	.+4      	; 0x208 <SetStatLED2+0x8>
	{
		PORTD &= ~_BV(UI_STAT2);
 204:	5f 98       	cbi	0x0b, 7	; 11
 206:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 208:	5f 9a       	sbi	0x0b, 7	; 11
 20a:	08 95       	ret

0000020c <VolDownTask>:
	SendPacket('D',&SendMsgPayLoad,1);
}

void VolDownTask(void)
{
	SendMsgPayLoad[0]=0x05;
 20c:	85 e0       	ldi	r24, 0x05	; 5
 20e:	80 93 13 01 	sts	0x0113, r24
	SendPacket('D',&SendMsgPayLoad,1);
 212:	84 e4       	ldi	r24, 0x44	; 68
 214:	63 e1       	ldi	r22, 0x13	; 19
 216:	71 e0       	ldi	r23, 0x01	; 1
 218:	41 e0       	ldi	r20, 0x01	; 1
 21a:	50 e0       	ldi	r21, 0x00	; 0
 21c:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
}
 220:	08 95       	ret

00000222 <VolUpTask>:
	SendPacket('D',&SendMsgPayLoad,1);
}

void VolUpTask(void)
{
	SendMsgPayLoad[0]=0x06;
 222:	86 e0       	ldi	r24, 0x06	; 6
 224:	80 93 13 01 	sts	0x0113, r24
	SendPacket('D',&SendMsgPayLoad,1);
 228:	84 e4       	ldi	r24, 0x44	; 68
 22a:	63 e1       	ldi	r22, 0x13	; 19
 22c:	71 e0       	ldi	r23, 0x01	; 1
 22e:	41 e0       	ldi	r20, 0x01	; 1
 230:	50 e0       	ldi	r21, 0x00	; 0
 232:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
}
 236:	08 95       	ret

00000238 <Mode2Task>:

void SetStatLED1(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT1);
 238:	5e 98       	cbi	0x0b, 6	; 11
}

void Mode2Task(void)
{
	SetStatLED1(false);
	SendMsgPayLoad[0]=0x04;
 23a:	84 e0       	ldi	r24, 0x04	; 4
 23c:	80 93 13 01 	sts	0x0113, r24
	SendPacket('D',&SendMsgPayLoad,1);
 240:	84 e4       	ldi	r24, 0x44	; 68
 242:	63 e1       	ldi	r22, 0x13	; 19
 244:	71 e0       	ldi	r23, 0x01	; 1
 246:	41 e0       	ldi	r20, 0x01	; 1
 248:	50 e0       	ldi	r21, 0x00	; 0
 24a:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
}
 24e:	08 95       	ret

00000250 <Mode1Task>:
	{
		PORTD &= ~_BV(UI_STAT1);
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 250:	5e 9a       	sbi	0x0b, 6	; 11
}

void Mode1Task(void)
{
	SetStatLED1(true);
	SendMsgPayLoad[0]=0x03;
 252:	83 e0       	ldi	r24, 0x03	; 3
 254:	80 93 13 01 	sts	0x0113, r24
	SendPacket('D',&SendMsgPayLoad,1);
 258:	84 e4       	ldi	r24, 0x44	; 68
 25a:	63 e1       	ldi	r22, 0x13	; 19
 25c:	71 e0       	ldi	r23, 0x01	; 1
 25e:	41 e0       	ldi	r20, 0x01	; 1
 260:	50 e0       	ldi	r21, 0x00	; 0
 262:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
}
 266:	08 95       	ret

00000268 <Enter2Task>:

void SetStatLED2(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT2);
 268:	5f 98       	cbi	0x0b, 7	; 11
}

void Enter2Task(void)
{
	SetStatLED2(false);
	SendMsgPayLoad[0]=0x02;
 26a:	82 e0       	ldi	r24, 0x02	; 2
 26c:	80 93 13 01 	sts	0x0113, r24
	SendMsgPayLoad[1]='E';
 270:	85 e4       	ldi	r24, 0x45	; 69
 272:	80 93 14 01 	sts	0x0114, r24
	SendPacket('D',&SendMsgPayLoad,2);
 276:	84 e4       	ldi	r24, 0x44	; 68
 278:	63 e1       	ldi	r22, 0x13	; 19
 27a:	71 e0       	ldi	r23, 0x01	; 1
 27c:	42 e0       	ldi	r20, 0x02	; 2
 27e:	50 e0       	ldi	r21, 0x00	; 0
 280:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
}
 284:	08 95       	ret

00000286 <Enter1Task>:
	{
		PORTD &= ~_BV(UI_STAT2);
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 286:	5f 9a       	sbi	0x0b, 7	; 11
}

void Enter1Task(void)
{
	SetStatLED2(true);
	SendMsgPayLoad[0]=0x01;
 288:	81 e0       	ldi	r24, 0x01	; 1
 28a:	80 93 13 01 	sts	0x0113, r24
	SendPacket('D',&SendMsgPayLoad,1);
 28e:	84 e4       	ldi	r24, 0x44	; 68
 290:	63 e1       	ldi	r22, 0x13	; 19
 292:	71 e0       	ldi	r23, 0x01	; 1
 294:	41 e0       	ldi	r20, 0x01	; 1
 296:	50 e0       	ldi	r21, 0x00	; 0
 298:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
	CaptureCellValue();
 29c:	0e 94 b3 03 	call	0x766	; 0x766 <CaptureCellValue>
}
 2a0:	08 95       	ret

000002a2 <RunCommandTasks>:
	}
}

void RunCommandTasks(void)
{
	if(Enter1State==1)
 2a2:	80 91 48 01 	lds	r24, 0x0148
 2a6:	81 30       	cpi	r24, 0x01	; 1
 2a8:	29 f4       	brne	.+10     	; 0x2b4 <RunCommandTasks+0x12>
	{
		Enter1Task();
 2aa:	0e 94 43 01 	call	0x286	; 0x286 <Enter1Task>
		Enter1State=2;	//Set it as used
 2ae:	82 e0       	ldi	r24, 0x02	; 2
 2b0:	80 93 48 01 	sts	0x0148, r24
	}
	if(Enter2State==1)
 2b4:	80 91 12 01 	lds	r24, 0x0112
 2b8:	81 30       	cpi	r24, 0x01	; 1
 2ba:	29 f4       	brne	.+10     	; 0x2c6 <RunCommandTasks+0x24>
	{
		Enter2Task();
 2bc:	0e 94 34 01 	call	0x268	; 0x268 <Enter2Task>
		Enter2State=2;	//Set it as used
 2c0:	82 e0       	ldi	r24, 0x02	; 2
 2c2:	80 93 12 01 	sts	0x0112, r24
	}
	if(Mode1State==1)
 2c6:	80 91 45 01 	lds	r24, 0x0145
 2ca:	81 30       	cpi	r24, 0x01	; 1
 2cc:	29 f4       	brne	.+10     	; 0x2d8 <RunCommandTasks+0x36>
	{
		Mode1Task();
 2ce:	0e 94 28 01 	call	0x250	; 0x250 <Mode1Task>
		Mode1State=2;	//Set it as used
 2d2:	82 e0       	ldi	r24, 0x02	; 2
 2d4:	80 93 45 01 	sts	0x0145, r24
	}
	if(Mode2State==1)
 2d8:	80 91 46 01 	lds	r24, 0x0146
 2dc:	81 30       	cpi	r24, 0x01	; 1
 2de:	29 f4       	brne	.+10     	; 0x2ea <RunCommandTasks+0x48>
	{
		Mode2Task();
 2e0:	0e 94 1c 01 	call	0x238	; 0x238 <Mode2Task>
		Mode2State=2;	//Set it as used
 2e4:	82 e0       	ldi	r24, 0x02	; 2
 2e6:	80 93 46 01 	sts	0x0146, r24
	}
	if((VolDownState>=1)&&(VolUpState>=1)) //Flip the keyboard
 2ea:	80 91 28 01 	lds	r24, 0x0128
 2ee:	88 23       	and	r24, r24
 2f0:	71 f0       	breq	.+28     	; 0x30e <RunCommandTasks+0x6c>
 2f2:	80 91 47 01 	lds	r24, 0x0147
 2f6:	88 23       	and	r24, r24
 2f8:	51 f0       	breq	.+20     	; 0x30e <RunCommandTasks+0x6c>
	{
		if(InterfaceType==1)
 2fa:	80 91 27 01 	lds	r24, 0x0127
 2fe:	81 30       	cpi	r24, 0x01	; 1
 300:	11 f4       	brne	.+4      	; 0x306 <RunCommandTasks+0x64>
		{
			InterfaceType=2;
 302:	82 e0       	ldi	r24, 0x02	; 2
 304:	01 c0       	rjmp	.+2      	; 0x308 <RunCommandTasks+0x66>
		}
		else
		{
			InterfaceType=1;
 306:	81 e0       	ldi	r24, 0x01	; 1
 308:	80 93 27 01 	sts	0x0127, r24
 30c:	08 95       	ret
		}
		return 0;
	}
	if(VolUpState==1)
 30e:	80 91 47 01 	lds	r24, 0x0147
 312:	81 30       	cpi	r24, 0x01	; 1
 314:	29 f4       	brne	.+10     	; 0x320 <RunCommandTasks+0x7e>
	{
		VolUpTask();
 316:	0e 94 11 01 	call	0x222	; 0x222 <VolUpTask>
		VolUpState=2;	//Set it as used
 31a:	82 e0       	ldi	r24, 0x02	; 2
 31c:	80 93 47 01 	sts	0x0147, r24
	}
	if(VolDownState==1)
 320:	80 91 28 01 	lds	r24, 0x0128
 324:	81 30       	cpi	r24, 0x01	; 1
 326:	29 f4       	brne	.+10     	; 0x332 <RunCommandTasks+0x90>
	{
		VolDownTask();
 328:	0e 94 06 01 	call	0x20c	; 0x20c <VolDownTask>
		VolDownState=2;	//Set it as used
 32c:	82 e0       	ldi	r24, 0x02	; 2
 32e:	80 93 28 01 	sts	0x0128, r24
 332:	08 95       	ret

00000334 <InitializeAnalogPorts>:
bool LED_ONOFF;

void InitializeAnalogPorts()
{

	ADCSRA |= 0xEF;
 334:	ea e7       	ldi	r30, 0x7A	; 122
 336:	f0 e0       	ldi	r31, 0x00	; 0
 338:	80 81       	ld	r24, Z
 33a:	8f 6e       	ori	r24, 0xEF	; 239
 33c:	80 83       	st	Z, r24
	ADCSRB=0x00;
 33e:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x67;
 342:	87 e6       	ldi	r24, 0x67	; 103
 344:	80 93 7c 00 	sts	0x007C, r24
	DIDR0=0x3F;
 348:	8f e3       	ldi	r24, 0x3F	; 63
 34a:	80 93 7e 00 	sts	0x007E, r24
	int i=0;
	for(i=0;i<6;i++)
	{
		ADC_LastVal[i]=0;
 34e:	10 92 1c 01 	sts	0x011C, r1
 352:	10 92 1b 01 	sts	0x011B, r1
 356:	10 92 1e 01 	sts	0x011E, r1
 35a:	10 92 1d 01 	sts	0x011D, r1
 35e:	10 92 20 01 	sts	0x0120, r1
 362:	10 92 1f 01 	sts	0x011F, r1
 366:	10 92 22 01 	sts	0x0122, r1
 36a:	10 92 21 01 	sts	0x0121, r1
 36e:	10 92 24 01 	sts	0x0124, r1
 372:	10 92 23 01 	sts	0x0123, r1
 376:	10 92 26 01 	sts	0x0126, r1
 37a:	10 92 25 01 	sts	0x0125, r1
	}
	LED_ONOFF=false;
 37e:	10 92 4c 01 	sts	0x014C, r1
}
 382:	08 95       	ret

00000384 <StartMeasurement>:
----------------------------------------------------------
THESE ARE NOT BEING USED
*/
void StartMeasurement(void)
{
	ADCSRA =0xCE;
 384:	8e ec       	ldi	r24, 0xCE	; 206
 386:	80 93 7a 00 	sts	0x007A, r24
}
 38a:	08 95       	ret

0000038c <StopMeasurement>:

void StopMeasurement(void)
{

}
 38c:	08 95       	ret

0000038e <MeasureInput>:
 38e:	80 e1       	ldi	r24, 0x10	; 16
 390:	97 e2       	ldi	r25, 0x27	; 39
 392:	01 97       	sbiw	r24, 0x01	; 1
 394:	f1 f7       	brne	.-4      	; 0x392 <MeasureInput+0x4>
 396:	e0 e0       	ldi	r30, 0x00	; 0
 398:	f0 e0       	ldi	r31, 0x00	; 0
 39a:	60 e0       	ldi	r22, 0x00	; 0
 39c:	70 e0       	ldi	r23, 0x00	; 0
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
	{
		ADC_COMPLETE=false;
 39e:	a0 e1       	ldi	r26, 0x10	; 16
 3a0:	b7 e2       	ldi	r27, 0x27	; 39
 3a2:	10 92 1a 01 	sts	0x011A, r1
 3a6:	cd 01       	movw	r24, r26
 3a8:	01 97       	sbiw	r24, 0x01	; 1
 3aa:	f1 f7       	brne	.-4      	; 0x3a8 <MeasureInput+0x1a>
		//StartMeasurement();
		_delay_ms(5);
		valADC=((ADCH<<8) | ADCL);
 3ac:	80 91 79 00 	lds	r24, 0x0079
 3b0:	20 91 78 00 	lds	r18, 0x0078
 3b4:	58 2f       	mov	r21, r24
 3b6:	40 e0       	ldi	r20, 0x00	; 0
 3b8:	30 e0       	ldi	r19, 0x00	; 0
 3ba:	24 2b       	or	r18, r20
 3bc:	35 2b       	or	r19, r21
 3be:	30 93 4e 01 	sts	0x014E, r19
 3c2:	20 93 4d 01 	sts	0x014D, r18
		//while(!ADC_COMPLETE);
		iVal+=valADC;
 3c6:	80 91 4d 01 	lds	r24, 0x014D
 3ca:	90 91 4e 01 	lds	r25, 0x014E
 3ce:	e8 0f       	add	r30, r24
 3d0:	f9 1f       	adc	r31, r25
 3d2:	cd 01       	movw	r24, r26
 3d4:	01 97       	sbiw	r24, 0x01	; 1
 3d6:	f1 f7       	brne	.-4      	; 0x3d4 <MeasureInput+0x46>
{
	//ADMUX = 0x40 + whichADC;
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
 3d8:	6f 5f       	subi	r22, 0xFF	; 255
 3da:	7f 4f       	sbci	r23, 0xFF	; 255
 3dc:	6a 30       	cpi	r22, 0x0A	; 10
 3de:	71 05       	cpc	r23, r1
 3e0:	01 f7       	brne	.-64     	; 0x3a2 <MeasureInput+0x14>
 3e2:	cf 01       	movw	r24, r30
 3e4:	6a e0       	ldi	r22, 0x0A	; 10
 3e6:	70 e0       	ldi	r23, 0x00	; 0
 3e8:	0e 94 2e 04 	call	0x85c	; 0x85c <__udivmodhi4>
 3ec:	cb 01       	movw	r24, r22
		iVal+=valADC;
		_delay_ms(5);
	}
	iVal=iVal/10;
	return iVal;
}
 3ee:	08 95       	ret

000003f0 <analog10>:
	uint16_t tADC0=0;
	uint16_t tADC[10];
	uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
 3f0:	80 5c       	subi	r24, 0xC0	; 192
 3f2:	80 93 7c 00 	sts	0x007C, r24
 3f6:	80 ea       	ldi	r24, 0xA0	; 160
 3f8:	9f e0       	ldi	r25, 0x0F	; 15
 3fa:	01 97       	sbiw	r24, 0x01	; 1
 3fc:	f1 f7       	brne	.-4      	; 0x3fa <analog10+0xa>
 3fe:	60 e0       	ldi	r22, 0x00	; 0
 400:	70 e0       	ldi	r23, 0x00	; 0
 402:	40 e0       	ldi	r20, 0x00	; 0
 404:	50 e0       	ldi	r21, 0x00	; 0
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
	{
		tADCH=ADCH;
 406:	a0 ed       	ldi	r26, 0xD0	; 208
 408:	b7 e0       	ldi	r27, 0x07	; 7
 40a:	20 91 79 00 	lds	r18, 0x0079
		tADCL=ADCL;	
 40e:	80 91 78 00 	lds	r24, 0x0078
 412:	fd 01       	movw	r30, r26
 414:	31 97       	sbiw	r30, 0x01	; 1
 416:	f1 f7       	brne	.-4      	; 0x414 <analog10+0x24>
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
 418:	32 2f       	mov	r19, r18
 41a:	20 e0       	ldi	r18, 0x00	; 0
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	82 2b       	or	r24, r18
 420:	93 2b       	or	r25, r19
 422:	48 0f       	add	r20, r24
 424:	59 1f       	adc	r21, r25
	uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
 426:	6f 5f       	subi	r22, 0xFF	; 255
 428:	7f 4f       	sbci	r23, 0xFF	; 255
 42a:	6a 30       	cpi	r22, 0x0A	; 10
 42c:	71 05       	cpc	r23, r1
 42e:	69 f7       	brne	.-38     	; 0x40a <analog10+0x1a>
		tADCL=ADCL;	
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
	}
	valADC=iVal/10;
 430:	ca 01       	movw	r24, r20
 432:	6a e0       	ldi	r22, 0x0A	; 10
 434:	70 e0       	ldi	r23, 0x00	; 0
 436:	0e 94 2e 04 	call	0x85c	; 0x85c <__udivmodhi4>
 43a:	70 93 4e 01 	sts	0x014E, r23
 43e:	60 93 4d 01 	sts	0x014D, r22
	return ADCH;
 442:	80 91 79 00 	lds	r24, 0x0079
}
 446:	08 95       	ret

00000448 <__vector_24>:

ISR(ADC_vect){
 448:	1f 92       	push	r1
 44a:	0f 92       	push	r0
 44c:	0f b6       	in	r0, 0x3f	; 63
 44e:	0f 92       	push	r0
 450:	11 24       	eor	r1, r1
	//valADC=((ADCH<<8) | ADCL);
	//ADC_COMPLETE=true;
}
 452:	0f 90       	pop	r0
 454:	0f be       	out	0x3f, r0	; 63
 456:	0f 90       	pop	r0
 458:	1f 90       	pop	r1
 45a:	18 95       	reti

0000045c <DetectTheDot>:

void DetectTheDot(void)
{	
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
	for(iADC=0;iADC<6;iADC++)
 460:	10 92 4f 01 	sts	0x014F, r1
 464:	c0 e4       	ldi	r28, 0x40	; 64
 466:	dc e9       	ldi	r29, 0x9C	; 156
 468:	4e c0       	rjmp	.+156    	; 0x506 <DetectTheDot+0xaa>
	{
		analog10(iADC);
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <analog10>
 470:	ce 01       	movw	r24, r28
 472:	01 97       	sbiw	r24, 0x01	; 1
 474:	f1 f7       	brne	.-4      	; 0x472 <DetectTheDot+0x16>
		_delay_ms(20);
		if(valADC!=ADC_LastVal[iADC])//If the value has changed
 476:	80 91 4d 01 	lds	r24, 0x014D
 47a:	90 91 4e 01 	lds	r25, 0x014E
 47e:	40 91 4f 01 	lds	r20, 0x014F
 482:	e4 2f       	mov	r30, r20
 484:	f0 e0       	ldi	r31, 0x00	; 0
 486:	ee 0f       	add	r30, r30
 488:	ff 1f       	adc	r31, r31
 48a:	e5 5e       	subi	r30, 0xE5	; 229
 48c:	fe 4f       	sbci	r31, 0xFE	; 254
 48e:	20 81       	ld	r18, Z
 490:	31 81       	ldd	r19, Z+1	; 0x01
 492:	82 17       	cp	r24, r18
 494:	93 07       	cpc	r25, r19
 496:	91 f1       	breq	.+100    	; 0x4fc <DetectTheDot+0xa0>
			This section is used only for debugging the UI.
			Once a change is detected, the analog value is sent directly to the 
			main unit with the message type 'E'. This will be sent to the terminal window
			by the main unit in the format [ADC channel,MSB,LSB].			
			*/
			SendMsgPayLoad[0]=iADC;
 498:	40 93 13 01 	sts	0x0113, r20
			SendMsgPayLoad[2]=(char)(valADC & 0x00ff);
 49c:	80 91 4d 01 	lds	r24, 0x014D
 4a0:	90 91 4e 01 	lds	r25, 0x014E
 4a4:	80 93 15 01 	sts	0x0115, r24
			SendMsgPayLoad[1]=(char)((valADC >> 8) & 0x00ff);
 4a8:	80 91 4d 01 	lds	r24, 0x014D
 4ac:	90 91 4e 01 	lds	r25, 0x014E
 4b0:	90 93 14 01 	sts	0x0114, r25
			SendPacket('E',&SendMsgPayLoad,3);
 4b4:	85 e4       	ldi	r24, 0x45	; 69
 4b6:	63 e1       	ldi	r22, 0x13	; 19
 4b8:	71 e0       	ldi	r23, 0x01	; 1
 4ba:	43 e0       	ldi	r20, 0x03	; 3
 4bc:	50 e0       	ldi	r21, 0x00	; 0
 4be:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
			/*
			---------------------------------------------------------
			*/
			ADC_LastVal[iADC]=valADC;
 4c2:	e0 91 4f 01 	lds	r30, 0x014F
 4c6:	f0 e0       	ldi	r31, 0x00	; 0
 4c8:	80 91 4d 01 	lds	r24, 0x014D
 4cc:	90 91 4e 01 	lds	r25, 0x014E
 4d0:	ee 0f       	add	r30, r30
 4d2:	ff 1f       	adc	r31, r31
 4d4:	e5 5e       	subi	r30, 0xE5	; 229
 4d6:	fe 4f       	sbci	r31, 0xFE	; 254
 4d8:	91 83       	std	Z+1, r25	; 0x01
 4da:	80 83       	st	Z, r24
			if(LED_ONOFF)
 4dc:	80 91 4c 01 	lds	r24, 0x014C
 4e0:	88 23       	and	r24, r24
 4e2:	31 f0       	breq	.+12     	; 0x4f0 <DetectTheDot+0x94>
			{
				SetStatLED1(false);
 4e4:	80 e0       	ldi	r24, 0x00	; 0
 4e6:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <SetStatLED1>
				LED_ONOFF=false;
 4ea:	10 92 4c 01 	sts	0x014C, r1
 4ee:	06 c0       	rjmp	.+12     	; 0x4fc <DetectTheDot+0xa0>
			}else
			{
				SetStatLED1(true);
 4f0:	81 e0       	ldi	r24, 0x01	; 1
 4f2:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <SetStatLED1>
				LED_ONOFF=true;
 4f6:	81 e0       	ldi	r24, 0x01	; 1
 4f8:	80 93 4c 01 	sts	0x014C, r24
	//ADC_COMPLETE=true;
}

void DetectTheDot(void)
{	
	for(iADC=0;iADC<6;iADC++)
 4fc:	80 91 4f 01 	lds	r24, 0x014F
 500:	8f 5f       	subi	r24, 0xFF	; 255
 502:	80 93 4f 01 	sts	0x014F, r24
 506:	80 91 4f 01 	lds	r24, 0x014F
 50a:	86 30       	cpi	r24, 0x06	; 6
 50c:	08 f4       	brcc	.+2      	; 0x510 <DetectTheDot+0xb4>
 50e:	ad cf       	rjmp	.-166    	; 0x46a <DetectTheDot+0xe>
				SetStatLED1(true);
				LED_ONOFF=true;
			}
		}
	}
}
 510:	df 91       	pop	r29
 512:	cf 91       	pop	r28
 514:	08 95       	ret

00000516 <init_USART_MCU>:

char TempBytes[20];

void init_USART_MCU(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
 516:	e1 ec       	ldi	r30, 0xC1	; 193
 518:	f0 e0       	ldi	r31, 0x00	; 0
 51a:	10 82       	st	Z, r1
	UCSR0A = 0x00;
 51c:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
 520:	86 e0       	ldi	r24, 0x06	; 6
 522:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x19;
 526:	89 e1       	ldi	r24, 0x19	; 25
 528:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate to 19,200 with 8MHz clock
 52c:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98; //RXCIE1=1, RXEN1=1, TXEN1=1
 530:	88 e9       	ldi	r24, 0x98	; 152
 532:	80 83       	st	Z, r24
}
 534:	08 95       	ret

00000536 <USART_RX_vect>:

ISR(USART_RX_vect){
 536:	1f 92       	push	r1
 538:	0f 92       	push	r0
 53a:	0f b6       	in	r0, 0x3f	; 63
 53c:	0f 92       	push	r0
 53e:	11 24       	eor	r1, r1
 540:	8f 93       	push	r24
	USART_MCU_Received_Data=UDR0;
 542:	80 91 c6 00 	lds	r24, 0x00C6
 546:	80 93 19 01 	sts	0x0119, r24
	USART_MCU_DATA_RDY=true;	
 54a:	81 e0       	ldi	r24, 0x01	; 1
 54c:	80 93 49 01 	sts	0x0149, r24
};
 550:	8f 91       	pop	r24
 552:	0f 90       	pop	r0
 554:	0f be       	out	0x3f, r0	; 63
 556:	0f 90       	pop	r0
 558:	1f 90       	pop	r1
 55a:	18 95       	reti

0000055c <USART_PC_ReceiveAction>:

void USART_PC_ReceiveAction(void){
	USART_MCU_DATA_RDY=false;
 55c:	10 92 49 01 	sts	0x0149, r1
	//USART_transmitByteToMCU(USART_PC_Received_Data);
}
 560:	08 95       	ret

00000562 <USART_transmitByteToMCU>:
 * UDRE0 : USART Data register empty (bit 5 of UCSR0A
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
 562:	98 2f       	mov	r25, r24
	while ( !(UCSR0A & (1<<UDRE0)) );
 564:	80 91 c0 00 	lds	r24, 0x00C0
 568:	85 ff       	sbrs	r24, 5
 56a:	fc cf       	rjmp	.-8      	; 0x564 <USART_transmitByteToMCU+0x2>
	UDR0 = bData;
 56c:	90 93 c6 00 	sts	0x00C6, r25
}
 570:	08 95       	ret

00000572 <USART_transmitStringToMCUFromFlash>:
 * @brief transmit a string from flash memory
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
 572:	fc 01       	movw	r30, r24
 574:	07 c0       	rjmp	.+14     	; 0x584 <USART_transmitStringToMCUFromFlash+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 576:	80 91 c0 00 	lds	r24, 0x00C0
 57a:	85 ff       	sbrs	r24, 5
 57c:	fc cf       	rjmp	.-8      	; 0x576 <USART_transmitStringToMCUFromFlash+0x4>
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
 57e:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 580:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
 584:	94 91       	lpm	r25, Z+
 586:	99 23       	and	r25, r25
 588:	b1 f7       	brne	.-20     	; 0x576 <USART_transmitStringToMCUFromFlash+0x4>
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
}
 58a:	08 95       	ret

0000058c <USART_transmitStringToMCU>:
 * @brief transmit a string to the data register
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
 58c:	fc 01       	movw	r30, r24
 58e:	07 c0       	rjmp	.+14     	; 0x59e <USART_transmitStringToMCU+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 590:	80 91 c0 00 	lds	r24, 0x00C0
 594:	85 ff       	sbrs	r24, 5
 596:	fc cf       	rjmp	.-8      	; 0x590 <USART_transmitStringToMCU+0x4>
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
   USART_transmitByteToMCU(*strData++);
 598:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 59a:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
 59e:	90 81       	ld	r25, Z
 5a0:	99 23       	and	r25, r25
 5a2:	b1 f7       	brne	.-20     	; 0x590 <USART_transmitStringToMCU+0x4>
   USART_transmitByteToMCU(*strData++);
}
 5a4:	08 95       	ret

000005a6 <initTimer>:

int TmrCntADC;

void initTimer(void)
{
	TMR1_INT=false;
 5a6:	10 92 18 01 	sts	0x0118, r1
	TCCR1A=0x00;
 5aa:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0x0D;
 5ae:	8d e0       	ldi	r24, 0x0D	; 13
 5b0:	80 93 81 00 	sts	0x0081, r24
	OCR1A=780; //1s interval
 5b4:	8c e0       	ldi	r24, 0x0C	; 12
 5b6:	93 e0       	ldi	r25, 0x03	; 3
 5b8:	90 93 89 00 	sts	0x0089, r25
 5bc:	80 93 88 00 	sts	0x0088, r24
	TIMSK1 |= (1<<OCIE1A); //Enable interrupt
 5c0:	ef e6       	ldi	r30, 0x6F	; 111
 5c2:	f0 e0       	ldi	r31, 0x00	; 0
 5c4:	80 81       	ld	r24, Z
 5c6:	82 60       	ori	r24, 0x02	; 2
 5c8:	80 83       	st	Z, r24
	TmrCntADC=0;
 5ca:	10 92 66 01 	sts	0x0166, r1
 5ce:	10 92 65 01 	sts	0x0165, r1
}
 5d2:	08 95       	ret

000005d4 <__vector_13>:

ISR(TIMER1_COMPA_vect){
 5d4:	1f 92       	push	r1
 5d6:	0f 92       	push	r0
 5d8:	0f b6       	in	r0, 0x3f	; 63
 5da:	0f 92       	push	r0
 5dc:	11 24       	eor	r1, r1
 5de:	8f 93       	push	r24
	TMR1_INT=true;
 5e0:	81 e0       	ldi	r24, 0x01	; 1
 5e2:	80 93 18 01 	sts	0x0118, r24
};
 5e6:	8f 91       	pop	r24
 5e8:	0f 90       	pop	r0
 5ea:	0f be       	out	0x3f, r0	; 63
 5ec:	0f 90       	pop	r0
 5ee:	1f 90       	pop	r1
 5f0:	18 95       	reti

000005f2 <TimerRoutine>:

void TimerRoutine(void)
{
	TMR1_INT=false;
 5f2:	10 92 18 01 	sts	0x0118, r1
	USART_transmitStringToMCU("hello small waves");
 5f6:	80 e0       	ldi	r24, 0x00	; 0
 5f8:	91 e0       	ldi	r25, 0x01	; 1
 5fa:	0e 94 c6 02 	call	0x58c	; 0x58c <USART_transmitStringToMCU>
		SetStatLED2(false);
		SetStatLED1(true);
		LED_STAT=false;
	}
	/*/
	CheckCommandButtons();
 5fe:	0e 94 9c 00 	call	0x138	; 0x138 <CheckCommandButtons>
	RunCommandTasks();
 602:	0e 94 51 01 	call	0x2a2	; 0x2a2 <RunCommandTasks>
	if(TmrCntADC<2)
 606:	80 91 65 01 	lds	r24, 0x0165
 60a:	90 91 66 01 	lds	r25, 0x0166
 60e:	82 30       	cpi	r24, 0x02	; 2
 610:	91 05       	cpc	r25, r1
 612:	34 f4       	brge	.+12     	; 0x620 <TimerRoutine+0x2e>
	{
		TmrCntADC++;
 614:	01 96       	adiw	r24, 0x01	; 1
 616:	90 93 66 01 	sts	0x0166, r25
 61a:	80 93 65 01 	sts	0x0165, r24
 61e:	08 95       	ret
	}else
	{
		DetectTheDot();
 620:	0e 94 2e 02 	call	0x45c	; 0x45c <DetectTheDot>
		ProcessTheDot();
 624:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <ProcessTheDot>
		TmrCntADC=0;
 628:	10 92 66 01 	sts	0x0166, r1
 62c:	10 92 65 01 	sts	0x0165, r1
 630:	08 95       	ret

00000632 <Calculate_CRC>:
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 632:	0f 93       	push	r16
 634:	1f 93       	push	r17
 636:	cf 93       	push	r28
 638:	df 93       	push	r29
 63a:	fc 01       	movw	r30, r24
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
 63c:	b2 81       	ldd	r27, Z+2	; 0x02
	uint16_t chksum=0;
	pstrMsg+=3;
 63e:	8c 01       	movw	r16, r24
 640:	0d 5f       	subi	r16, 0xFD	; 253
 642:	1f 4f       	sbci	r17, 0xFF	; 255
 644:	60 e0       	ldi	r22, 0x00	; 0
 646:	70 e0       	ldi	r23, 0x00	; 0
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 648:	b5 50       	subi	r27, 0x05	; 5
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 64a:	ab 2f       	mov	r26, r27
 64c:	a6 95       	lsr	r26
 64e:	ca 2f       	mov	r28, r26
 650:	d0 e0       	ldi	r29, 0x00	; 0
 652:	ae 01       	movw	r20, r28
 654:	4f 5f       	subi	r20, 0xFF	; 255
 656:	5f 4f       	sbci	r21, 0xFF	; 255
 658:	44 0f       	add	r20, r20
 65a:	55 1f       	adc	r21, r21
 65c:	4e 0f       	add	r20, r30
 65e:	5f 1f       	adc	r21, r31
 660:	08 c0       	rjmp	.+16     	; 0x672 <Calculate_CRC+0x40>
	{
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
 662:	31 81       	ldd	r19, Z+1	; 0x01
 664:	20 e0       	ldi	r18, 0x00	; 0
 666:	82 81       	ldd	r24, Z+2	; 0x02
 668:	90 e0       	ldi	r25, 0x00	; 0
 66a:	82 2b       	or	r24, r18
 66c:	93 2b       	or	r25, r19
 66e:	68 0f       	add	r22, r24
 670:	79 1f       	adc	r23, r25
 672:	32 96       	adiw	r30, 0x02	; 2
uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 674:	e4 17       	cp	r30, r20
 676:	f5 07       	cpc	r31, r21
 678:	a1 f7       	brne	.-24     	; 0x662 <Calculate_CRC+0x30>
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 67a:	aa 0f       	add	r26, r26
 67c:	fe 01       	movw	r30, r28
 67e:	ee 0f       	add	r30, r30
 680:	ff 1f       	adc	r31, r31
 682:	e0 0f       	add	r30, r16
 684:	f1 1f       	adc	r31, r17
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
		chksum = chksum & 0xffff;
		msglen-=2;
		pstrMsg+=2;
	}
	if(msglen>0) //If the packet size is odd numbered
 686:	ba 17       	cp	r27, r26
 688:	21 f0       	breq	.+8      	; 0x692 <Calculate_CRC+0x60>
	{
		chksum = chksum^ (int)*(pstrMsg++);
 68a:	80 81       	ld	r24, Z
 68c:	90 e0       	ldi	r25, 0x00	; 0
 68e:	68 27       	eor	r22, r24
 690:	79 27       	eor	r23, r25
	}
	return(chksum);
}
 692:	cb 01       	movw	r24, r22
 694:	df 91       	pop	r29
 696:	cf 91       	pop	r28
 698:	1f 91       	pop	r17
 69a:	0f 91       	pop	r16
 69c:	08 95       	ret

0000069e <MCU_PKT_CompilePacket>:

bool MCU_PKT_CompilePacket(char cmd, char* pl, int plLen)
{
 69e:	cf 93       	push	r28
 6a0:	df 93       	push	r29
 6a2:	98 2f       	mov	r25, r24
 6a4:	db 01       	movw	r26, r22
 6a6:	ea 01       	movw	r28, r20
	// [U][I][msglen][msg_number][msgtype][payload][CRC1][CRC2]
	uint16_t chksum;
	//Header always contain the 0xFA and 0xFB
	MCU_Packet[0]='U';
 6a8:	85 e5       	ldi	r24, 0x55	; 85
 6aa:	80 93 31 01 	sts	0x0131, r24
	MCU_Packet[1]='I';
 6ae:	89 e4       	ldi	r24, 0x49	; 73
 6b0:	80 93 32 01 	sts	0x0132, r24
	iPktSize=plLen+7;
 6b4:	27 96       	adiw	r28, 0x07	; 7
 6b6:	d0 93 2a 01 	sts	0x012A, r29
 6ba:	c0 93 29 01 	sts	0x0129, r28
 6be:	27 97       	sbiw	r28, 0x07	; 7
	if ( plLen+7 > 20 ) //SABT can handle packets upto 20 bytes 
 6c0:	ce 30       	cpi	r28, 0x0E	; 14
 6c2:	d1 05       	cpc	r29, r1
 6c4:	14 f0       	brlt	.+4      	; 0x6ca <MCU_PKT_CompilePacket+0x2c>
 6c6:	80 e0       	ldi	r24, 0x00	; 0
 6c8:	22 c0       	rjmp	.+68     	; 0x70e <MCU_PKT_CompilePacket+0x70>
	{
		return(false);
	}
	MCU_Packet[2] = plLen+7;
 6ca:	9e 01       	movw	r18, r28
 6cc:	29 5f       	subi	r18, 0xF9	; 249
 6ce:	20 93 33 01 	sts	0x0133, r18
	MCU_Packet[3] = 2;	
 6d2:	82 e0       	ldi	r24, 0x02	; 2
 6d4:	80 93 34 01 	sts	0x0134, r24
	MCU_Packet[4] = cmd;	
 6d8:	90 93 35 01 	sts	0x0135, r25
 6dc:	20 e0       	ldi	r18, 0x00	; 0
 6de:	30 e0       	ldi	r19, 0x00	; 0
 6e0:	07 c0       	rjmp	.+14     	; 0x6f0 <MCU_PKT_CompilePacket+0x52>
	int i=0;
	for(i=0;i<plLen;i++)
	{
		MCU_Packet[5+i]=*(pl++);
 6e2:	8d 91       	ld	r24, X+
 6e4:	f9 01       	movw	r30, r18
 6e6:	ea 5c       	subi	r30, 0xCA	; 202
 6e8:	fe 4f       	sbci	r31, 0xFE	; 254
 6ea:	80 83       	st	Z, r24
	}
	MCU_Packet[2] = plLen+7;
	MCU_Packet[3] = 2;	
	MCU_Packet[4] = cmd;	
	int i=0;
	for(i=0;i<plLen;i++)
 6ec:	2f 5f       	subi	r18, 0xFF	; 255
 6ee:	3f 4f       	sbci	r19, 0xFF	; 255
 6f0:	2c 17       	cp	r18, r28
 6f2:	3d 07       	cpc	r19, r29
 6f4:	b4 f3       	brlt	.-20     	; 0x6e2 <MCU_PKT_CompilePacket+0x44>
	{
		MCU_Packet[5+i]=*(pl++);
	}
	//memcpy( &MCU_Packet[5], pl, plLen);
	chksum = Calculate_CRC(&MCU_Packet);
 6f6:	81 e3       	ldi	r24, 0x31	; 49
 6f8:	91 e0       	ldi	r25, 0x01	; 1
 6fa:	0e 94 19 03 	call	0x632	; 0x632 <Calculate_CRC>
	MCU_Packet[plLen+5] = chksum >> 8;
 6fe:	fe 01       	movw	r30, r28
 700:	ea 5c       	subi	r30, 0xCA	; 202
 702:	fe 4f       	sbci	r31, 0xFE	; 254
 704:	90 83       	st	Z, r25
	MCU_Packet[plLen+6] = chksum & 0xFF;	
 706:	c9 5c       	subi	r28, 0xC9	; 201
 708:	de 4f       	sbci	r29, 0xFE	; 254
 70a:	88 83       	st	Y, r24
 70c:	81 e0       	ldi	r24, 0x01	; 1
	return(true);
}
 70e:	df 91       	pop	r29
 710:	cf 91       	pop	r28
 712:	08 95       	ret

00000714 <SendPacket>:

void SendPacket(char cmd, char* payLoad, int plLen)
{
 714:	cf 93       	push	r28
 716:	df 93       	push	r29
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
 718:	0e 94 4f 03 	call	0x69e	; 0x69e <MCU_PKT_CompilePacket>
 71c:	88 23       	and	r24, r24
 71e:	89 f0       	breq	.+34     	; 0x742 <SendPacket+0x2e>
 720:	c0 e0       	ldi	r28, 0x00	; 0
 722:	d0 e0       	ldi	r29, 0x00	; 0
 724:	07 c0       	rjmp	.+14     	; 0x734 <SendPacket+0x20>
	{
		for(i=0;i<iPktSize;i++)
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
 726:	fe 01       	movw	r30, r28
 728:	ef 5c       	subi	r30, 0xCF	; 207
 72a:	fe 4f       	sbci	r31, 0xFE	; 254
 72c:	80 81       	ld	r24, Z
 72e:	0e 94 b1 02 	call	0x562	; 0x562 <USART_transmitByteToMCU>
void SendPacket(char cmd, char* payLoad, int plLen)
{
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
	{
		for(i=0;i<iPktSize;i++)
 732:	21 96       	adiw	r28, 0x01	; 1
 734:	80 91 29 01 	lds	r24, 0x0129
 738:	90 91 2a 01 	lds	r25, 0x012A
 73c:	c8 17       	cp	r28, r24
 73e:	d9 07       	cpc	r29, r25
 740:	94 f3       	brlt	.-28     	; 0x726 <SendPacket+0x12>
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
		}
	}	

}
 742:	df 91       	pop	r29
 744:	cf 91       	pop	r28
 746:	08 95       	ret

00000748 <ResetCellState>:
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 748:	10 92 2b 01 	sts	0x012B, r1
 74c:	10 92 2c 01 	sts	0x012C, r1
 750:	10 92 2d 01 	sts	0x012D, r1
 754:	10 92 2e 01 	sts	0x012E, r1
 758:	10 92 2f 01 	sts	0x012F, r1
 75c:	10 92 30 01 	sts	0x0130, r1
	}
	PI_LastDotPressed=0;
 760:	10 92 68 01 	sts	0x0168, r1
}
 764:	08 95       	ret

00000766 <CaptureCellValue>:
	}
}


void CaptureCellValue(void)
{
 766:	20 e0       	ldi	r18, 0x00	; 0
 768:	30 e0       	ldi	r19, 0x00	; 0
 76a:	40 e0       	ldi	r20, 0x00	; 0
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
 76c:	61 e0       	ldi	r22, 0x01	; 1
 76e:	70 e0       	ldi	r23, 0x00	; 0
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
 770:	f9 01       	movw	r30, r18
 772:	e5 5d       	subi	r30, 0xD5	; 213
 774:	fe 4f       	sbci	r31, 0xFE	; 254
 776:	80 81       	ld	r24, Z
 778:	88 23       	and	r24, r24
 77a:	41 f0       	breq	.+16     	; 0x78c <CaptureCellValue+0x26>
		{
			ProcessedCellValue |= _BV(i);
 77c:	cb 01       	movw	r24, r22
 77e:	02 2e       	mov	r0, r18
 780:	02 c0       	rjmp	.+4      	; 0x786 <CaptureCellValue+0x20>
 782:	88 0f       	add	r24, r24
 784:	99 1f       	adc	r25, r25
 786:	0a 94       	dec	r0
 788:	e2 f7       	brpl	.-8      	; 0x782 <CaptureCellValue+0x1c>
 78a:	48 2b       	or	r20, r24
	/*
	This section process the stored dot values and
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
 78c:	2f 5f       	subi	r18, 0xFF	; 255
 78e:	3f 4f       	sbci	r19, 0xFF	; 255
 790:	26 30       	cpi	r18, 0x06	; 6
 792:	31 05       	cpc	r19, r1
 794:	69 f7       	brne	.-38     	; 0x770 <CaptureCellValue+0xa>
 796:	40 93 67 01 	sts	0x0167, r20
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
		}
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
 79a:	40 93 13 01 	sts	0x0113, r20
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
 79e:	81 e0       	ldi	r24, 0x01	; 1
 7a0:	80 93 14 01 	sts	0x0114, r24
	SendPacket('B',&SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
 7a4:	82 e4       	ldi	r24, 0x42	; 66
 7a6:	63 e1       	ldi	r22, 0x13	; 19
 7a8:	71 e0       	ldi	r23, 0x01	; 1
 7aa:	42 e0       	ldi	r20, 0x02	; 2
 7ac:	50 e0       	ldi	r21, 0x00	; 0
 7ae:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 7b2:	10 92 2b 01 	sts	0x012B, r1
 7b6:	10 92 2c 01 	sts	0x012C, r1
 7ba:	10 92 2d 01 	sts	0x012D, r1
 7be:	10 92 2e 01 	sts	0x012E, r1
 7c2:	10 92 2f 01 	sts	0x012F, r1
 7c6:	10 92 30 01 	sts	0x0130, r1
	}
	PI_LastDotPressed=0;
 7ca:	10 92 68 01 	sts	0x0168, r1
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
	SendPacket('B',&SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
	ResetCellState();						//Reset the cell state so that new letter can start
}
 7ce:	08 95       	ret

000007d0 <ProcessTheDot>:
void ProcessTheDot(void)
{
	uint8_t TempDot=0;
	uint8_t PI_ThisDot;
	bool NewDotDetected=false;
	if(!(PINC & (1<<UI_BR1))) //Dot1
 7d0:	34 99       	sbic	0x06, 4	; 6
 7d2:	03 c0       	rjmp	.+6      	; 0x7da <ProcessTheDot+0xa>
 7d4:	91 e0       	ldi	r25, 0x01	; 1
 7d6:	81 e0       	ldi	r24, 0x01	; 1
 7d8:	02 c0       	rjmp	.+4      	; 0x7de <ProcessTheDot+0xe>
 7da:	90 e0       	ldi	r25, 0x00	; 0
 7dc:	80 e0       	ldi	r24, 0x00	; 0
	{
		NewDotDetected=true;
		TempDot=1;
	}
	if(!(PINC & (1<<UI_BR2))) //Dot1
 7de:	31 99       	sbic	0x06, 1	; 6
 7e0:	02 c0       	rjmp	.+4      	; 0x7e6 <ProcessTheDot+0x16>
 7e2:	92 e0       	ldi	r25, 0x02	; 2
 7e4:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=2;
	}
	if(!(PINC & (1<<UI_BR3))) //Dot1
 7e6:	35 99       	sbic	0x06, 5	; 6
 7e8:	02 c0       	rjmp	.+4      	; 0x7ee <ProcessTheDot+0x1e>
 7ea:	93 e0       	ldi	r25, 0x03	; 3
 7ec:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=3;
	}
	if(!(PINC & (1<<UI_BR4))) //Dot1
 7ee:	32 99       	sbic	0x06, 2	; 6
 7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <ProcessTheDot+0x26>
 7f2:	94 e0       	ldi	r25, 0x04	; 4
 7f4:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=4;
	}
	if(!(PINC & (1<<UI_BR5))) //Dot1
 7f6:	33 99       	sbic	0x06, 3	; 6
 7f8:	02 c0       	rjmp	.+4      	; 0x7fe <ProcessTheDot+0x2e>
 7fa:	95 e0       	ldi	r25, 0x05	; 5
 7fc:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=5;
	}
	if(!(PINC & (1<<UI_BR6))) //Dot1
 7fe:	30 99       	sbic	0x06, 0	; 6
 800:	02 c0       	rjmp	.+4      	; 0x806 <ProcessTheDot+0x36>
 802:	96 e0       	ldi	r25, 0x06	; 6
 804:	02 c0       	rjmp	.+4      	; 0x80a <ProcessTheDot+0x3a>
	{
		NewDotDetected=true;
		TempDot=6;
	}

	if(NewDotDetected)
 806:	88 23       	and	r24, r24
 808:	41 f1       	breq	.+80     	; 0x85a <ProcessTheDot+0x8a>
	{
		if(InterfaceType==1)
 80a:	80 91 27 01 	lds	r24, 0x0127
 80e:	81 30       	cpi	r24, 0x01	; 1
 810:	49 f0       	breq	.+18     	; 0x824 <ProcessTheDot+0x54>
		{
			//OK this is the default			
		}else if(InterfaceType==2)
 812:	80 91 27 01 	lds	r24, 0x0127
 816:	82 30       	cpi	r24, 0x02	; 2
 818:	29 f4       	brne	.+10     	; 0x824 <ProcessTheDot+0x54>
		{
			//OK Flip the pattern
			if(TempDot>3) TempDot-=3;
 81a:	94 30       	cpi	r25, 0x04	; 4
 81c:	10 f0       	brcs	.+4      	; 0x822 <ProcessTheDot+0x52>
 81e:	93 50       	subi	r25, 0x03	; 3
 820:	01 c0       	rjmp	.+2      	; 0x824 <ProcessTheDot+0x54>
			else TempDot+=3;
 822:	9d 5f       	subi	r25, 0xFD	; 253
		}
		if(PI_LastDotPressed==TempDot) return;
 824:	80 91 68 01 	lds	r24, 0x0168
 828:	89 17       	cp	r24, r25
 82a:	b9 f0       	breq	.+46     	; 0x85a <ProcessTheDot+0x8a>
		PI_LastDotPressed=TempDot;
 82c:	90 93 68 01 	sts	0x0168, r25
		DotsPressed[TempDot-1]=true;
 830:	e9 2f       	mov	r30, r25
 832:	f0 e0       	ldi	r31, 0x00	; 0
 834:	e6 5d       	subi	r30, 0xD6	; 214
 836:	fe 4f       	sbci	r31, 0xFE	; 254
 838:	81 e0       	ldi	r24, 0x01	; 1
 83a:	80 83       	st	Z, r24
		SendMsgPayLoad[0]=0x30+PI_LastDotPressed;
 83c:	90 5d       	subi	r25, 0xD0	; 208
 83e:	90 93 13 01 	sts	0x0113, r25
		SendMsgPayLoad[1]=0x31;
 842:	81 e3       	ldi	r24, 0x31	; 49
 844:	80 93 14 01 	sts	0x0114, r24
		SendMsgPayLoad[2]=0x31;
 848:	80 93 15 01 	sts	0x0115, r24
    	SendPacket('A',&SendMsgPayLoad,3);
 84c:	81 e4       	ldi	r24, 0x41	; 65
 84e:	63 e1       	ldi	r22, 0x13	; 19
 850:	71 e0       	ldi	r23, 0x01	; 1
 852:	43 e0       	ldi	r20, 0x03	; 3
 854:	50 e0       	ldi	r21, 0x00	; 0
 856:	0e 94 8a 03 	call	0x714	; 0x714 <SendPacket>
 85a:	08 95       	ret

0000085c <__udivmodhi4>:
 85c:	aa 1b       	sub	r26, r26
 85e:	bb 1b       	sub	r27, r27
 860:	51 e1       	ldi	r21, 0x11	; 17
 862:	07 c0       	rjmp	.+14     	; 0x872 <__udivmodhi4_ep>

00000864 <__udivmodhi4_loop>:
 864:	aa 1f       	adc	r26, r26
 866:	bb 1f       	adc	r27, r27
 868:	a6 17       	cp	r26, r22
 86a:	b7 07       	cpc	r27, r23
 86c:	10 f0       	brcs	.+4      	; 0x872 <__udivmodhi4_ep>
 86e:	a6 1b       	sub	r26, r22
 870:	b7 0b       	sbc	r27, r23

00000872 <__udivmodhi4_ep>:
 872:	88 1f       	adc	r24, r24
 874:	99 1f       	adc	r25, r25
 876:	5a 95       	dec	r21
 878:	a9 f7       	brne	.-22     	; 0x864 <__udivmodhi4_loop>
 87a:	80 95       	com	r24
 87c:	90 95       	com	r25
 87e:	bc 01       	movw	r22, r24
 880:	cd 01       	movw	r24, r26
 882:	08 95       	ret

00000884 <_exit>:
 884:	f8 94       	cli

00000886 <__stop_program>:
 886:	ff cf       	rjmp	.-2      	; 0x886 <__stop_program>
