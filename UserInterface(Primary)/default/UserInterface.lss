
UserInterface.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000882  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000057  00800100  00800100  000008f6  2**0
                  ALLOC
  2 .debug_aranges 000000e0  00000000  00000000  000008f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000b0b  00000000  00000000  000009d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00001742  00000000  00000000  000014e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000070b  00000000  00000000  00002c23  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000010c7  00000000  00000000  0000332e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000290  00000000  00000000  000043f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000050a  00000000  00000000  00004688  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000040a  00000000  00000000  00004b92  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000108  00000000  00000000  00004f9c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 95 02 	jmp	0x52a	; 0x52a <__vector_20>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 1e 02 	jmp	0x43c	; 0x43c <__vector_24>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e2 e8       	ldi	r30, 0x82	; 130
  a0:	f8 e0       	ldi	r31, 0x08	; 8
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a0 30       	cpi	r26, 0x00	; 0
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a0 e0       	ldi	r26, 0x00	; 0
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a7 35       	cpi	r26, 0x57	; 87
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 72 00 	call	0xe4	; 0xe4 <main>
  c6:	0c 94 3f 04 	jmp	0x87e	; 0x87e <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <InitializeUI>:
 * @brief initialize basic elements of the UI board
 */
void InitializeUI(void)
{
	//Initialize the Serial comm with the main module
	init_USART_MCU();
  ce:	0e 94 85 02 	call	0x50a	; 0x50a <init_USART_MCU>
	//Initialize the analog ports
  //TODO: why is this commented out?
	//InitializeAnalogPorts();

	//Initialize the digital input/output pins
	Initialize_Digital_IO();
  d2:	0e 94 78 00 	call	0xf0	; 0xf0 <Initialize_Digital_IO>

	// Initialize the timer
	initTimer();
  d6:	0e 94 cd 02 	call	0x59a	; 0x59a <initTimer>

	// Enable interrupts
	sei();
  da:	78 94       	sei

	InterfaceType=1;
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	80 93 15 01 	sts	0x0115, r24
}
  e2:	08 95       	ret

000000e4 <main>:
 * Executes an infinite loop, should never return
 * @return 0
 */
int main(void)
{
	InitializeUI();
  e4:	0e 94 67 00 	call	0xce	; 0xce <InitializeUI>
	//SendMsgPayLoad[0]=0x01;
    //SendPacket('D',(char *)SendMsgPayLoad,5);
	USART_transmitByteToMCU('Q');
  e8:	81 e5       	ldi	r24, 0x51	; 81
  ea:	0e 94 ab 02 	call	0x556	; 0x556 <USART_transmitByteToMCU>
  ee:	fc cf       	rjmp	.-8      	; 0xe8 <main+0x4>

000000f0 <Initialize_Digital_IO>:
#include "GlobalsUI.h"

void Initialize_Digital_IO(void)
{
	Enter1State=0;
  f0:	10 92 36 01 	sts	0x0136, r1
	Enter2State=0;
  f4:	10 92 00 01 	sts	0x0100, r1
	Mode1State=0;
  f8:	10 92 33 01 	sts	0x0133, r1
	Mode2State=0;
  fc:	10 92 34 01 	sts	0x0134, r1
	VolUpState=0;
 100:	10 92 35 01 	sts	0x0135, r1
	VolDownState=0;
 104:	10 92 16 01 	sts	0x0116, r1
		
	DDRC &= ~_BV(UI_BR1);	
 108:	3c 98       	cbi	0x07, 4	; 7
	DDRC &= ~_BV(UI_BR2);
 10a:	39 98       	cbi	0x07, 1	; 7
	DDRC &= ~_BV(UI_BR3);
 10c:	3d 98       	cbi	0x07, 5	; 7
	DDRC &= ~_BV(UI_BR4);
 10e:	3a 98       	cbi	0x07, 2	; 7
	DDRC &= ~_BV(UI_BR5);
 110:	3b 98       	cbi	0x07, 3	; 7
	DDRC &= ~_BV(UI_BR6);
 112:	38 98       	cbi	0x07, 0	; 7

	DDRB &= ~_BV(UI_ENTER1);
 114:	27 98       	cbi	0x04, 7	; 4
	DDRB &= ~_BV(UI_ENTER2);
 116:	26 98       	cbi	0x04, 6	; 4
	DDRB &= ~_BV(UI_MODE1);
 118:	21 98       	cbi	0x04, 1	; 4
	DDRB &= ~_BV(UI_MODE2);
 11a:	20 98       	cbi	0x04, 0	; 4

	DDRD &= ~_BV(UI_VOLUP);
 11c:	53 98       	cbi	0x0a, 3	; 10
	DDRD &= ~_BV(UI_VOLDOWN);
 11e:	52 98       	cbi	0x0a, 2	; 10
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
 120:	8a b1       	in	r24, 0x0a	; 10
 122:	80 6c       	ori	r24, 0xC0	; 192
 124:	8a b9       	out	0x0a, r24	; 10

void SetStatLED1(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT1);
 126:	5e 98       	cbi	0x0b, 6	; 11

void SetStatLED2(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT2);
 128:	5f 98       	cbi	0x0b, 7	; 11
	DDRD &= ~_BV(UI_VOLDOWN);
	DDRD |= _BV(UI_STAT1)|_BV(UI_STAT2);
	//switch off stat LEDs
	SetStatLED1(false);
	SetStatLED2(false); 
}
 12a:	08 95       	ret

0000012c <CheckCommandButtons>:

void CheckCommandButtons(void)
{
	if(!(PINB & (1<<UI_ENTER1)))
 12c:	1f 99       	sbic	0x03, 7	; 3
 12e:	0a c0       	rjmp	.+20     	; 0x144 <CheckCommandButtons+0x18>
	{
		if(Enter1State==0)
 130:	80 91 36 01 	lds	r24, 0x0136
 134:	88 23       	and	r24, r24
 136:	41 f4       	brne	.+16     	; 0x148 <CheckCommandButtons+0x1c>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER1)))
 138:	1f 99       	sbic	0x03, 7	; 3
 13a:	06 c0       	rjmp	.+12     	; 0x148 <CheckCommandButtons+0x1c>
			{
				Enter1State=1;
 13c:	81 e0       	ldi	r24, 0x01	; 1
 13e:	80 93 36 01 	sts	0x0136, r24
 142:	02 c0       	rjmp	.+4      	; 0x148 <CheckCommandButtons+0x1c>
			}
		}
	}
	else
	{
		Enter1State=0;
 144:	10 92 36 01 	sts	0x0136, r1
	}

	if(!(PINB & (1<<UI_ENTER2)))
 148:	1e 99       	sbic	0x03, 6	; 3
 14a:	13 c0       	rjmp	.+38     	; 0x172 <CheckCommandButtons+0x46>
	{
		if(Enter2State==0)
 14c:	80 91 00 01 	lds	r24, 0x0100
 150:	88 23       	and	r24, r24
 152:	89 f4       	brne	.+34     	; 0x176 <CheckCommandButtons+0x4a>
 154:	88 ee       	ldi	r24, 0xE8	; 232
 156:	93 e0       	ldi	r25, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 158:	28 ec       	ldi	r18, 0xC8	; 200
 15a:	30 e0       	ldi	r19, 0x00	; 0
 15c:	f9 01       	movw	r30, r18
 15e:	31 97       	sbiw	r30, 0x01	; 1
 160:	f1 f7       	brne	.-4      	; 0x15e <CheckCommandButtons+0x32>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 162:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 164:	d9 f7       	brne	.-10     	; 0x15c <CheckCommandButtons+0x30>
		{
			_delay_ms(100);
			if(!(PINB & (1<<UI_ENTER2)))
 166:	1e 99       	sbic	0x03, 6	; 3
 168:	06 c0       	rjmp	.+12     	; 0x176 <CheckCommandButtons+0x4a>
			{
				Enter2State=1;
 16a:	81 e0       	ldi	r24, 0x01	; 1
 16c:	80 93 00 01 	sts	0x0100, r24
 170:	02 c0       	rjmp	.+4      	; 0x176 <CheckCommandButtons+0x4a>
			}
		}
	}
	else
	{
		Enter2State=0;
 172:	10 92 00 01 	sts	0x0100, r1
	}

	if(!(PINB & (1<<UI_MODE1)))
 176:	19 99       	sbic	0x03, 1	; 3
 178:	0a c0       	rjmp	.+20     	; 0x18e <CheckCommandButtons+0x62>
	{
		if(Mode1State==0)
 17a:	80 91 33 01 	lds	r24, 0x0133
 17e:	88 23       	and	r24, r24
 180:	41 f4       	brne	.+16     	; 0x192 <CheckCommandButtons+0x66>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE1)))
 182:	19 99       	sbic	0x03, 1	; 3
 184:	06 c0       	rjmp	.+12     	; 0x192 <CheckCommandButtons+0x66>
			{
				Mode1State=1;
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	80 93 33 01 	sts	0x0133, r24
 18c:	02 c0       	rjmp	.+4      	; 0x192 <CheckCommandButtons+0x66>
			}
		}
	}
	else
	{
		Mode1State=0;
 18e:	10 92 33 01 	sts	0x0133, r1
	}

	if(!(PINB & (1<<UI_MODE2)))
 192:	18 99       	sbic	0x03, 0	; 3
 194:	0a c0       	rjmp	.+20     	; 0x1aa <CheckCommandButtons+0x7e>
	{
		if(Mode2State==0)
 196:	80 91 34 01 	lds	r24, 0x0134
 19a:	88 23       	and	r24, r24
 19c:	41 f4       	brne	.+16     	; 0x1ae <CheckCommandButtons+0x82>
		{
			//_delay_ms(100);
			if(!(PINB & (1<<UI_MODE2)))
 19e:	18 99       	sbic	0x03, 0	; 3
 1a0:	06 c0       	rjmp	.+12     	; 0x1ae <CheckCommandButtons+0x82>
			{
				Mode2State=1;
 1a2:	81 e0       	ldi	r24, 0x01	; 1
 1a4:	80 93 34 01 	sts	0x0134, r24
 1a8:	02 c0       	rjmp	.+4      	; 0x1ae <CheckCommandButtons+0x82>
			}
		}
	}
	else
	{
		Mode2State=0;
 1aa:	10 92 34 01 	sts	0x0134, r1
	}

	if(!(PIND & (1<<UI_VOLUP)))
 1ae:	4b 99       	sbic	0x09, 3	; 9
 1b0:	0a c0       	rjmp	.+20     	; 0x1c6 <CheckCommandButtons+0x9a>
	{
		if(VolUpState==0)
 1b2:	80 91 35 01 	lds	r24, 0x0135
 1b6:	88 23       	and	r24, r24
 1b8:	41 f4       	brne	.+16     	; 0x1ca <CheckCommandButtons+0x9e>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLUP)))
 1ba:	4b 99       	sbic	0x09, 3	; 9
 1bc:	06 c0       	rjmp	.+12     	; 0x1ca <CheckCommandButtons+0x9e>
			{
				VolUpState=1;
 1be:	81 e0       	ldi	r24, 0x01	; 1
 1c0:	80 93 35 01 	sts	0x0135, r24
 1c4:	02 c0       	rjmp	.+4      	; 0x1ca <CheckCommandButtons+0x9e>
			}
		}
	}
	else
	{
		VolUpState=0;
 1c6:	10 92 35 01 	sts	0x0135, r1
	}

	if(!(PIND & (1<<UI_VOLDOWN)))
 1ca:	4a 99       	sbic	0x09, 2	; 9
 1cc:	0a c0       	rjmp	.+20     	; 0x1e2 <CheckCommandButtons+0xb6>
	{
		if(VolDownState==0)
 1ce:	80 91 16 01 	lds	r24, 0x0116
 1d2:	88 23       	and	r24, r24
 1d4:	41 f4       	brne	.+16     	; 0x1e6 <CheckCommandButtons+0xba>
		{
			//_delay_ms(100);
			if(!(PIND & (1<<UI_VOLDOWN)))
 1d6:	4a 99       	sbic	0x09, 2	; 9
 1d8:	06 c0       	rjmp	.+12     	; 0x1e6 <CheckCommandButtons+0xba>
			{
				VolDownState=1;
 1da:	81 e0       	ldi	r24, 0x01	; 1
 1dc:	80 93 16 01 	sts	0x0116, r24
 1e0:	08 95       	ret
			}
		}
	}
	else
	{
		VolDownState=0;
 1e2:	10 92 16 01 	sts	0x0116, r1
 1e6:	08 95       	ret

000001e8 <SetStatLED1>:
}
*/

void SetStatLED1(bool bState)
{
	if(!bState)
 1e8:	88 23       	and	r24, r24
 1ea:	11 f4       	brne	.+4      	; 0x1f0 <SetStatLED1+0x8>
	{
		PORTD &= ~_BV(UI_STAT1);
 1ec:	5e 98       	cbi	0x0b, 6	; 11
 1ee:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 1f0:	5e 9a       	sbi	0x0b, 6	; 11
 1f2:	08 95       	ret

000001f4 <SetStatLED2>:
	}
}

void SetStatLED2(bool bState)
{
	if(!bState)
 1f4:	88 23       	and	r24, r24
 1f6:	11 f4       	brne	.+4      	; 0x1fc <SetStatLED2+0x8>
	{
		PORTD &= ~_BV(UI_STAT2);
 1f8:	5f 98       	cbi	0x0b, 7	; 11
 1fa:	08 95       	ret
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 1fc:	5f 9a       	sbi	0x0b, 7	; 11
 1fe:	08 95       	ret

00000200 <VolDownTask>:
	SendPacket('D',(char*)SendMsgPayLoad,1);
}

void VolDownTask(void)
{
	SendMsgPayLoad[0]=0x05;
 200:	85 e0       	ldi	r24, 0x05	; 5
 202:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 206:	84 e4       	ldi	r24, 0x44	; 68
 208:	61 e0       	ldi	r22, 0x01	; 1
 20a:	71 e0       	ldi	r23, 0x01	; 1
 20c:	41 e0       	ldi	r20, 0x01	; 1
 20e:	50 e0       	ldi	r21, 0x00	; 0
 210:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
}
 214:	08 95       	ret

00000216 <VolUpTask>:
	SendPacket('D',(char*)SendMsgPayLoad,1);
}

void VolUpTask(void)
{
	SendMsgPayLoad[0]=0x06;
 216:	86 e0       	ldi	r24, 0x06	; 6
 218:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 21c:	84 e4       	ldi	r24, 0x44	; 68
 21e:	61 e0       	ldi	r22, 0x01	; 1
 220:	71 e0       	ldi	r23, 0x01	; 1
 222:	41 e0       	ldi	r20, 0x01	; 1
 224:	50 e0       	ldi	r21, 0x00	; 0
 226:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
}
 22a:	08 95       	ret

0000022c <Mode2Task>:

void SetStatLED1(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT1);
 22c:	5e 98       	cbi	0x0b, 6	; 11
}

void Mode2Task(void)
{
	SetStatLED1(false);
	SendMsgPayLoad[0]=0x04;
 22e:	84 e0       	ldi	r24, 0x04	; 4
 230:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 234:	84 e4       	ldi	r24, 0x44	; 68
 236:	61 e0       	ldi	r22, 0x01	; 1
 238:	71 e0       	ldi	r23, 0x01	; 1
 23a:	41 e0       	ldi	r20, 0x01	; 1
 23c:	50 e0       	ldi	r21, 0x00	; 0
 23e:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
}
 242:	08 95       	ret

00000244 <Mode1Task>:
	{
		PORTD &= ~_BV(UI_STAT1);
	}
	else
	{
		PORTD |= _BV(UI_STAT1);
 244:	5e 9a       	sbi	0x0b, 6	; 11
}

void Mode1Task(void)
{
	SetStatLED1(true);
	SendMsgPayLoad[0]=0x03;
 246:	83 e0       	ldi	r24, 0x03	; 3
 248:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 24c:	84 e4       	ldi	r24, 0x44	; 68
 24e:	61 e0       	ldi	r22, 0x01	; 1
 250:	71 e0       	ldi	r23, 0x01	; 1
 252:	41 e0       	ldi	r20, 0x01	; 1
 254:	50 e0       	ldi	r21, 0x00	; 0
 256:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
}
 25a:	08 95       	ret

0000025c <Enter2Task>:

void SetStatLED2(bool bState)
{
	if(!bState)
	{
		PORTD &= ~_BV(UI_STAT2);
 25c:	5f 98       	cbi	0x0b, 7	; 11
}

void Enter2Task(void)
{
	SetStatLED2(false);
	SendMsgPayLoad[0]=0x02;
 25e:	82 e0       	ldi	r24, 0x02	; 2
 260:	80 93 01 01 	sts	0x0101, r24
	SendMsgPayLoad[1]='E';
 264:	85 e4       	ldi	r24, 0x45	; 69
 266:	80 93 02 01 	sts	0x0102, r24
	SendPacket('D',(char*)SendMsgPayLoad,2);
 26a:	84 e4       	ldi	r24, 0x44	; 68
 26c:	61 e0       	ldi	r22, 0x01	; 1
 26e:	71 e0       	ldi	r23, 0x01	; 1
 270:	42 e0       	ldi	r20, 0x02	; 2
 272:	50 e0       	ldi	r21, 0x00	; 0
 274:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
}
 278:	08 95       	ret

0000027a <Enter1Task>:
	{
		PORTD &= ~_BV(UI_STAT2);
	}
	else
	{
		PORTD |= _BV(UI_STAT2);
 27a:	5f 9a       	sbi	0x0b, 7	; 11
}

void Enter1Task(void)
{
	SetStatLED2(true);
	SendMsgPayLoad[0]=0x01;
 27c:	81 e0       	ldi	r24, 0x01	; 1
 27e:	80 93 01 01 	sts	0x0101, r24
	SendPacket('D',(char*)SendMsgPayLoad,1);
 282:	84 e4       	ldi	r24, 0x44	; 68
 284:	61 e0       	ldi	r22, 0x01	; 1
 286:	71 e0       	ldi	r23, 0x01	; 1
 288:	41 e0       	ldi	r20, 0x01	; 1
 28a:	50 e0       	ldi	r21, 0x00	; 0
 28c:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
	CaptureCellValue();
 290:	0e 94 b0 03 	call	0x760	; 0x760 <CaptureCellValue>
}
 294:	08 95       	ret

00000296 <RunCommandTasks>:
	}
}

void RunCommandTasks(void)
{
	if(Enter1State==1)
 296:	80 91 36 01 	lds	r24, 0x0136
 29a:	81 30       	cpi	r24, 0x01	; 1
 29c:	29 f4       	brne	.+10     	; 0x2a8 <RunCommandTasks+0x12>
	{
		Enter1Task();
 29e:	0e 94 3d 01 	call	0x27a	; 0x27a <Enter1Task>
		Enter1State=2;	//Set it as used
 2a2:	82 e0       	ldi	r24, 0x02	; 2
 2a4:	80 93 36 01 	sts	0x0136, r24
	}
	if(Enter2State==1)
 2a8:	80 91 00 01 	lds	r24, 0x0100
 2ac:	81 30       	cpi	r24, 0x01	; 1
 2ae:	29 f4       	brne	.+10     	; 0x2ba <RunCommandTasks+0x24>
	{
		Enter2Task();
 2b0:	0e 94 2e 01 	call	0x25c	; 0x25c <Enter2Task>
		Enter2State=2;	//Set it as used
 2b4:	82 e0       	ldi	r24, 0x02	; 2
 2b6:	80 93 00 01 	sts	0x0100, r24
	}
	if(Mode1State==1)
 2ba:	80 91 33 01 	lds	r24, 0x0133
 2be:	81 30       	cpi	r24, 0x01	; 1
 2c0:	29 f4       	brne	.+10     	; 0x2cc <RunCommandTasks+0x36>
	{
		Mode1Task();
 2c2:	0e 94 22 01 	call	0x244	; 0x244 <Mode1Task>
		Mode1State=2;	//Set it as used
 2c6:	82 e0       	ldi	r24, 0x02	; 2
 2c8:	80 93 33 01 	sts	0x0133, r24
	}
	if(Mode2State==1)
 2cc:	80 91 34 01 	lds	r24, 0x0134
 2d0:	81 30       	cpi	r24, 0x01	; 1
 2d2:	29 f4       	brne	.+10     	; 0x2de <RunCommandTasks+0x48>
	{
		Mode2Task();
 2d4:	0e 94 16 01 	call	0x22c	; 0x22c <Mode2Task>
		Mode2State=2;	//Set it as used
 2d8:	82 e0       	ldi	r24, 0x02	; 2
 2da:	80 93 34 01 	sts	0x0134, r24
	}
	if((VolDownState>=1)&&(VolUpState>=1)) //Flip the keyboard
 2de:	80 91 16 01 	lds	r24, 0x0116
 2e2:	88 23       	and	r24, r24
 2e4:	71 f0       	breq	.+28     	; 0x302 <RunCommandTasks+0x6c>
 2e6:	80 91 35 01 	lds	r24, 0x0135
 2ea:	88 23       	and	r24, r24
 2ec:	51 f0       	breq	.+20     	; 0x302 <RunCommandTasks+0x6c>
	{
		if(InterfaceType==1)
 2ee:	80 91 15 01 	lds	r24, 0x0115
 2f2:	81 30       	cpi	r24, 0x01	; 1
 2f4:	11 f4       	brne	.+4      	; 0x2fa <RunCommandTasks+0x64>
		{
			InterfaceType=2;
 2f6:	82 e0       	ldi	r24, 0x02	; 2
 2f8:	01 c0       	rjmp	.+2      	; 0x2fc <RunCommandTasks+0x66>
		}
		else
		{
			InterfaceType=1;
 2fa:	81 e0       	ldi	r24, 0x01	; 1
 2fc:	80 93 15 01 	sts	0x0115, r24
 300:	08 95       	ret
		}
		return;
	}
	if(VolUpState==1)
 302:	80 91 35 01 	lds	r24, 0x0135
 306:	81 30       	cpi	r24, 0x01	; 1
 308:	29 f4       	brne	.+10     	; 0x314 <RunCommandTasks+0x7e>
	{
		VolUpTask();
 30a:	0e 94 0b 01 	call	0x216	; 0x216 <VolUpTask>
		VolUpState=2;	//Set it as used
 30e:	82 e0       	ldi	r24, 0x02	; 2
 310:	80 93 35 01 	sts	0x0135, r24
	}
	if(VolDownState==1)
 314:	80 91 16 01 	lds	r24, 0x0116
 318:	81 30       	cpi	r24, 0x01	; 1
 31a:	29 f4       	brne	.+10     	; 0x326 <RunCommandTasks+0x90>
	{
		VolDownTask();
 31c:	0e 94 00 01 	call	0x200	; 0x200 <VolDownTask>
		VolDownState=2;	//Set it as used
 320:	82 e0       	ldi	r24, 0x02	; 2
 322:	80 93 16 01 	sts	0x0116, r24
 326:	08 95       	ret

00000328 <InitializeAnalogPorts>:
bool LED_ONOFF;

void InitializeAnalogPorts()
{

	ADCSRA |= 0xEF;
 328:	ea e7       	ldi	r30, 0x7A	; 122
 32a:	f0 e0       	ldi	r31, 0x00	; 0
 32c:	80 81       	ld	r24, Z
 32e:	8f 6e       	ori	r24, 0xEF	; 239
 330:	80 83       	st	Z, r24
	ADCSRB=0x00;
 332:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x67;
 336:	87 e6       	ldi	r24, 0x67	; 103
 338:	80 93 7c 00 	sts	0x007C, r24
	DIDR0=0x3F;
 33c:	8f e3       	ldi	r24, 0x3F	; 63
 33e:	80 93 7e 00 	sts	0x007E, r24
	int i=0;
	for(i=0;i<6;i++)
	{
		ADC_LastVal[i]=0;
 342:	10 92 0a 01 	sts	0x010A, r1
 346:	10 92 09 01 	sts	0x0109, r1
 34a:	10 92 0c 01 	sts	0x010C, r1
 34e:	10 92 0b 01 	sts	0x010B, r1
 352:	10 92 0e 01 	sts	0x010E, r1
 356:	10 92 0d 01 	sts	0x010D, r1
 35a:	10 92 10 01 	sts	0x0110, r1
 35e:	10 92 0f 01 	sts	0x010F, r1
 362:	10 92 12 01 	sts	0x0112, r1
 366:	10 92 11 01 	sts	0x0111, r1
 36a:	10 92 14 01 	sts	0x0114, r1
 36e:	10 92 13 01 	sts	0x0113, r1
	}
	LED_ONOFF=false;
 372:	10 92 3a 01 	sts	0x013A, r1
}
 376:	08 95       	ret

00000378 <StartMeasurement>:
----------------------------------------------------------
THESE ARE NOT BEING USED
*/
void StartMeasurement(void)
{
	ADCSRA =0xCE;
 378:	8e ec       	ldi	r24, 0xCE	; 206
 37a:	80 93 7a 00 	sts	0x007A, r24
}
 37e:	08 95       	ret

00000380 <StopMeasurement>:

void StopMeasurement(void)
{

}
 380:	08 95       	ret

00000382 <MeasureInput>:
 382:	80 e1       	ldi	r24, 0x10	; 16
 384:	97 e2       	ldi	r25, 0x27	; 39
 386:	01 97       	sbiw	r24, 0x01	; 1
 388:	f1 f7       	brne	.-4      	; 0x386 <MeasureInput+0x4>
 38a:	e0 e0       	ldi	r30, 0x00	; 0
 38c:	f0 e0       	ldi	r31, 0x00	; 0
 38e:	60 e0       	ldi	r22, 0x00	; 0
 390:	70 e0       	ldi	r23, 0x00	; 0
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
	{
		ADC_COMPLETE=false;
 392:	a0 e1       	ldi	r26, 0x10	; 16
 394:	b7 e2       	ldi	r27, 0x27	; 39
 396:	10 92 08 01 	sts	0x0108, r1
 39a:	cd 01       	movw	r24, r26
 39c:	01 97       	sbiw	r24, 0x01	; 1
 39e:	f1 f7       	brne	.-4      	; 0x39c <MeasureInput+0x1a>
		//StartMeasurement();
		_delay_ms(5);
		valADC=((ADCH<<8) | ADCL);
 3a0:	80 91 79 00 	lds	r24, 0x0079
 3a4:	20 91 78 00 	lds	r18, 0x0078
 3a8:	58 2f       	mov	r21, r24
 3aa:	40 e0       	ldi	r20, 0x00	; 0
 3ac:	30 e0       	ldi	r19, 0x00	; 0
 3ae:	24 2b       	or	r18, r20
 3b0:	35 2b       	or	r19, r21
 3b2:	30 93 3c 01 	sts	0x013C, r19
 3b6:	20 93 3b 01 	sts	0x013B, r18
		//while(!ADC_COMPLETE);
		iVal+=valADC;
 3ba:	80 91 3b 01 	lds	r24, 0x013B
 3be:	90 91 3c 01 	lds	r25, 0x013C
 3c2:	e8 0f       	add	r30, r24
 3c4:	f9 1f       	adc	r31, r25
 3c6:	cd 01       	movw	r24, r26
 3c8:	01 97       	sbiw	r24, 0x01	; 1
 3ca:	f1 f7       	brne	.-4      	; 0x3c8 <MeasureInput+0x46>
{
	//ADMUX = 0x40 + whichADC;
	_delay_ms(5);
	uint16_t iVal=0;
	int i=0;
	for(i=0;i<10;i++)
 3cc:	6f 5f       	subi	r22, 0xFF	; 255
 3ce:	7f 4f       	sbci	r23, 0xFF	; 255
 3d0:	6a 30       	cpi	r22, 0x0A	; 10
 3d2:	71 05       	cpc	r23, r1
 3d4:	01 f7       	brne	.-64     	; 0x396 <MeasureInput+0x14>
 3d6:	cf 01       	movw	r24, r30
 3d8:	6a e0       	ldi	r22, 0x0A	; 10
 3da:	70 e0       	ldi	r23, 0x00	; 0
 3dc:	0e 94 2b 04 	call	0x856	; 0x856 <__udivmodhi4>
 3e0:	cb 01       	movw	r24, r22
		iVal+=valADC;
		_delay_ms(5);
	}
	iVal=iVal/10;
	return iVal;
}
 3e2:	08 95       	ret

000003e4 <analog10>:
	//uint16_t tADC0=0;
	uint16_t tADC[10];
	//uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
 3e4:	80 5c       	subi	r24, 0xC0	; 192
 3e6:	80 93 7c 00 	sts	0x007C, r24
 3ea:	80 ea       	ldi	r24, 0xA0	; 160
 3ec:	9f e0       	ldi	r25, 0x0F	; 15
 3ee:	01 97       	sbiw	r24, 0x01	; 1
 3f0:	f1 f7       	brne	.-4      	; 0x3ee <analog10+0xa>
 3f2:	60 e0       	ldi	r22, 0x00	; 0
 3f4:	70 e0       	ldi	r23, 0x00	; 0
 3f6:	40 e0       	ldi	r20, 0x00	; 0
 3f8:	50 e0       	ldi	r21, 0x00	; 0
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
	{
		tADCH=ADCH;
 3fa:	a0 ed       	ldi	r26, 0xD0	; 208
 3fc:	b7 e0       	ldi	r27, 0x07	; 7
 3fe:	20 91 79 00 	lds	r18, 0x0079
		tADCL=ADCL;	
 402:	80 91 78 00 	lds	r24, 0x0078
 406:	fd 01       	movw	r30, r26
 408:	31 97       	sbiw	r30, 0x01	; 1
 40a:	f1 f7       	brne	.-4      	; 0x408 <analog10+0x24>
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
 40c:	32 2f       	mov	r19, r18
 40e:	20 e0       	ldi	r18, 0x00	; 0
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	82 2b       	or	r24, r18
 414:	93 2b       	or	r25, r19
 416:	48 0f       	add	r20, r24
 418:	59 1f       	adc	r21, r25
	//uint16_t eADC;
	uint16_t iVal=0;
	//bool ADC_STABLE=false;
	ADMUX = 0x40 + which;
	_delay_ms(2); // need at least 130 us between conversions
	for(i=0;i<10;i++)
 41a:	6f 5f       	subi	r22, 0xFF	; 255
 41c:	7f 4f       	sbci	r23, 0xFF	; 255
 41e:	6a 30       	cpi	r22, 0x0A	; 10
 420:	71 05       	cpc	r23, r1
 422:	69 f7       	brne	.-38     	; 0x3fe <analog10+0x1a>
		tADCL=ADCL;	
		_delay_ms(1);
		tADC[i]=((tADCH<<8) | tADCL);
		iVal+=tADC[i];
	}
	valADC=iVal/10;
 424:	ca 01       	movw	r24, r20
 426:	6a e0       	ldi	r22, 0x0A	; 10
 428:	70 e0       	ldi	r23, 0x00	; 0
 42a:	0e 94 2b 04 	call	0x856	; 0x856 <__udivmodhi4>
 42e:	70 93 3c 01 	sts	0x013C, r23
 432:	60 93 3b 01 	sts	0x013B, r22
	return ADCH;
 436:	80 91 79 00 	lds	r24, 0x0079
}
 43a:	08 95       	ret

0000043c <__vector_24>:

ISR(ADC_vect){
 43c:	1f 92       	push	r1
 43e:	0f 92       	push	r0
 440:	0f b6       	in	r0, 0x3f	; 63
 442:	0f 92       	push	r0
 444:	11 24       	eor	r1, r1
	//valADC=((ADCH<<8) | ADCL);
	//ADC_COMPLETE=true;
}
 446:	0f 90       	pop	r0
 448:	0f be       	out	0x3f, r0	; 63
 44a:	0f 90       	pop	r0
 44c:	1f 90       	pop	r1
 44e:	18 95       	reti

00000450 <DetectTheDot>:

void DetectTheDot(void)
{	
 450:	cf 93       	push	r28
 452:	df 93       	push	r29
	for(iADC=0;iADC<6;iADC++)
 454:	10 92 3d 01 	sts	0x013D, r1
 458:	c0 e4       	ldi	r28, 0x40	; 64
 45a:	dc e9       	ldi	r29, 0x9C	; 156
 45c:	4e c0       	rjmp	.+156    	; 0x4fa <DetectTheDot+0xaa>
	{
		analog10(iADC);
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <analog10>
 464:	ce 01       	movw	r24, r28
 466:	01 97       	sbiw	r24, 0x01	; 1
 468:	f1 f7       	brne	.-4      	; 0x466 <DetectTheDot+0x16>
		_delay_ms(20);
		if(valADC!=ADC_LastVal[iADC])//If the value has changed
 46a:	80 91 3b 01 	lds	r24, 0x013B
 46e:	90 91 3c 01 	lds	r25, 0x013C
 472:	40 91 3d 01 	lds	r20, 0x013D
 476:	e4 2f       	mov	r30, r20
 478:	f0 e0       	ldi	r31, 0x00	; 0
 47a:	ee 0f       	add	r30, r30
 47c:	ff 1f       	adc	r31, r31
 47e:	e7 5f       	subi	r30, 0xF7	; 247
 480:	fe 4f       	sbci	r31, 0xFE	; 254
 482:	20 81       	ld	r18, Z
 484:	31 81       	ldd	r19, Z+1	; 0x01
 486:	82 17       	cp	r24, r18
 488:	93 07       	cpc	r25, r19
 48a:	91 f1       	breq	.+100    	; 0x4f0 <DetectTheDot+0xa0>
			This section is used only for debugging the UI.
			Once a change is detected, the analog value is sent directly to the 
			main unit with the message type 'E'. This will be sent to the terminal window
			by the main unit in the format [ADC channel,MSB,LSB].			
			*/
			SendMsgPayLoad[0]=iADC;
 48c:	40 93 01 01 	sts	0x0101, r20
			SendMsgPayLoad[2]=(char)(valADC & 0x00ff);
 490:	80 91 3b 01 	lds	r24, 0x013B
 494:	90 91 3c 01 	lds	r25, 0x013C
 498:	80 93 03 01 	sts	0x0103, r24
			SendMsgPayLoad[1]=(char)((valADC >> 8) & 0x00ff);
 49c:	80 91 3b 01 	lds	r24, 0x013B
 4a0:	90 91 3c 01 	lds	r25, 0x013C
 4a4:	90 93 02 01 	sts	0x0102, r25
			SendPacket('E',(char*)SendMsgPayLoad,3);
 4a8:	85 e4       	ldi	r24, 0x45	; 69
 4aa:	61 e0       	ldi	r22, 0x01	; 1
 4ac:	71 e0       	ldi	r23, 0x01	; 1
 4ae:	43 e0       	ldi	r20, 0x03	; 3
 4b0:	50 e0       	ldi	r21, 0x00	; 0
 4b2:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
			/*
			---------------------------------------------------------
			*/
			ADC_LastVal[iADC]=valADC;
 4b6:	e0 91 3d 01 	lds	r30, 0x013D
 4ba:	f0 e0       	ldi	r31, 0x00	; 0
 4bc:	80 91 3b 01 	lds	r24, 0x013B
 4c0:	90 91 3c 01 	lds	r25, 0x013C
 4c4:	ee 0f       	add	r30, r30
 4c6:	ff 1f       	adc	r31, r31
 4c8:	e7 5f       	subi	r30, 0xF7	; 247
 4ca:	fe 4f       	sbci	r31, 0xFE	; 254
 4cc:	91 83       	std	Z+1, r25	; 0x01
 4ce:	80 83       	st	Z, r24
			if(LED_ONOFF)
 4d0:	80 91 3a 01 	lds	r24, 0x013A
 4d4:	88 23       	and	r24, r24
 4d6:	31 f0       	breq	.+12     	; 0x4e4 <DetectTheDot+0x94>
			{
				SetStatLED1(false);
 4d8:	80 e0       	ldi	r24, 0x00	; 0
 4da:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <SetStatLED1>
				LED_ONOFF=false;
 4de:	10 92 3a 01 	sts	0x013A, r1
 4e2:	06 c0       	rjmp	.+12     	; 0x4f0 <DetectTheDot+0xa0>
			}else
			{
				SetStatLED1(true);
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <SetStatLED1>
				LED_ONOFF=true;
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	80 93 3a 01 	sts	0x013A, r24
	//ADC_COMPLETE=true;
}

void DetectTheDot(void)
{	
	for(iADC=0;iADC<6;iADC++)
 4f0:	80 91 3d 01 	lds	r24, 0x013D
 4f4:	8f 5f       	subi	r24, 0xFF	; 255
 4f6:	80 93 3d 01 	sts	0x013D, r24
 4fa:	80 91 3d 01 	lds	r24, 0x013D
 4fe:	86 30       	cpi	r24, 0x06	; 6
 500:	08 f4       	brcc	.+2      	; 0x504 <DetectTheDot+0xb4>
 502:	ad cf       	rjmp	.-166    	; 0x45e <DetectTheDot+0xe>
				SetStatLED1(true);
				LED_ONOFF=true;
			}
		}
	}
}
 504:	df 91       	pop	r29
 506:	cf 91       	pop	r28
 508:	08 95       	ret

0000050a <init_USART_MCU>:
 * Clock: 8MHz
 * @return Void
 */
void init_USART_MCU(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
 50a:	e1 ec       	ldi	r30, 0xC1	; 193
 50c:	f0 e0       	ldi	r31, 0x00	; 0
 50e:	10 82       	st	Z, r1
	UCSR0A = 0x00;
 510:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
 514:	86 e0       	ldi	r24, 0x06	; 6
 516:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x19;
 51a:	89 e1       	ldi	r24, 0x19	; 25
 51c:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate to 19,200 with 8MHz clock
 520:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98; //RXCIE1=1, RXEN1=1, TXEN1=1
 524:	88 e9       	ldi	r24, 0x98	; 152
 526:	80 83       	st	Z, r24
}
 528:	08 95       	ret

0000052a <__vector_20>:

// TODO: what does this do?
ISR(USART0_RX_vect){
 52a:	1f 92       	push	r1
 52c:	0f 92       	push	r0
 52e:	0f b6       	in	r0, 0x3f	; 63
 530:	0f 92       	push	r0
 532:	11 24       	eor	r1, r1
 534:	8f 93       	push	r24
	USART_MCU_Received_Data=UDR0;
 536:	80 91 c6 00 	lds	r24, 0x00C6
 53a:	80 93 07 01 	sts	0x0107, r24
	USART_MCU_DATA_RDY=true;	
 53e:	81 e0       	ldi	r24, 0x01	; 1
 540:	80 93 37 01 	sts	0x0137, r24
};
 544:	8f 91       	pop	r24
 546:	0f 90       	pop	r0
 548:	0f be       	out	0x3f, r0	; 63
 54a:	0f 90       	pop	r0
 54c:	1f 90       	pop	r1
 54e:	18 95       	reti

00000550 <USART_PC_ReceiveAction>:
 * @brief receive action sent from PC
 * TODO: why is line commented out / how does it work
 * @return Void
 */
void USART_PC_ReceiveAction(void){
	USART_MCU_DATA_RDY=false;
 550:	10 92 37 01 	sts	0x0137, r1
	//USART_transmitByteToMCU(USART_PC_Received_Data);
}
 554:	08 95       	ret

00000556 <USART_transmitByteToMCU>:
 * UDRE0 : USART Data register empty (bit 5 of UCSR0A
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
 556:	98 2f       	mov	r25, r24
	while ( !(UCSR0A & (1<<UDRE0)) );
 558:	80 91 c0 00 	lds	r24, 0x00C0
 55c:	85 ff       	sbrs	r24, 5
 55e:	fc cf       	rjmp	.-8      	; 0x558 <USART_transmitByteToMCU+0x2>
	UDR0 = bData;
 560:	90 93 c6 00 	sts	0x00C6, r25
}
 564:	08 95       	ret

00000566 <USART_transmitStringToMCUFromFlash>:
 * @brief transmit a string from flash memory
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
 566:	fc 01       	movw	r30, r24
 568:	07 c0       	rjmp	.+14     	; 0x578 <USART_transmitStringToMCUFromFlash+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 56a:	80 91 c0 00 	lds	r24, 0x00C0
 56e:	85 ff       	sbrs	r24, 5
 570:	fc cf       	rjmp	.-8      	; 0x56a <USART_transmitStringToMCUFromFlash+0x4>
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
 572:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 574:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginnning of the string in flash mem
 * @return Void
 */
void USART_transmitStringToMCUFromFlash(char* strData)
{
  while (pgm_read_byte(&(*strData)))
 578:	94 91       	lpm	r25, Z+
 57a:	99 23       	and	r25, r25
 57c:	b1 f7       	brne	.-20     	; 0x56a <USART_transmitStringToMCUFromFlash+0x4>
   USART_transmitByteToMCU(pgm_read_byte(&(*strData++)));
}
 57e:	08 95       	ret

00000580 <USART_transmitStringToMCU>:
 * @brief transmit a string to the data register
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
 580:	fc 01       	movw	r30, r24
 582:	07 c0       	rjmp	.+14     	; 0x592 <USART_transmitStringToMCU+0x12>
 * UDR0 : Data register
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
 584:	80 91 c0 00 	lds	r24, 0x00C0
 588:	85 ff       	sbrs	r24, 5
 58a:	fc cf       	rjmp	.-8      	; 0x584 <USART_transmitStringToMCU+0x4>
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
   USART_transmitByteToMCU(*strData++);
 58c:	31 96       	adiw	r30, 0x01	; 1
 * @return Void (transmits data)
 */
void USART_transmitByteToMCU( unsigned char bData )
{
	while ( !(UCSR0A & (1<<UDRE0)) );
	UDR0 = bData;
 58e:	90 93 c6 00 	sts	0x00C6, r25
 * @param strData pointer to the beginning of the string
 * @return Void
 */
void USART_transmitStringToMCU(unsigned char* strData)
{
  while (*strData)
 592:	90 81       	ld	r25, Z
 594:	99 23       	and	r25, r25
 596:	b1 f7       	brne	.-20     	; 0x584 <USART_transmitStringToMCU+0x4>
   USART_transmitByteToMCU(*strData++);
}
 598:	08 95       	ret

0000059a <initTimer>:
 * @brief Initialize the timer
 * @return Void
 */
void initTimer(void)
{
	TMR1_INT=false;
 59a:	10 92 06 01 	sts	0x0106, r1
	TCCR1A=0x00;
 59e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0x0D;
 5a2:	8d e0       	ldi	r24, 0x0D	; 13
 5a4:	80 93 81 00 	sts	0x0081, r24
	OCR1A=780; //1s interval
 5a8:	8c e0       	ldi	r24, 0x0C	; 12
 5aa:	93 e0       	ldi	r25, 0x03	; 3
 5ac:	90 93 89 00 	sts	0x0089, r25
 5b0:	80 93 88 00 	sts	0x0088, r24
	TIMSK1 |= (1<<OCIE1A); //Enable interrupt
 5b4:	ef e6       	ldi	r30, 0x6F	; 111
 5b6:	f0 e0       	ldi	r31, 0x00	; 0
 5b8:	80 81       	ld	r24, Z
 5ba:	82 60       	ori	r24, 0x02	; 2
 5bc:	80 83       	st	Z, r24
	TmrCntADC=0;
 5be:	10 92 54 01 	sts	0x0154, r1
 5c2:	10 92 53 01 	sts	0x0153, r1
}
 5c6:	08 95       	ret

000005c8 <TimerRoutine>:
	//TMR1_INT=true;
//};

void TimerRoutine(void)
{
	TMR1_INT=false;
 5c8:	10 92 06 01 	sts	0x0106, r1
	//USART_transmitStringToMCU("hello small waves");
	//
	if(!LED_STAT){
 5cc:	80 91 52 01 	lds	r24, 0x0152
 5d0:	88 23       	and	r24, r24
 5d2:	51 f4       	brne	.+20     	; 0x5e8 <TimerRoutine+0x20>
		SetStatLED2(true);
 5d4:	81 e0       	ldi	r24, 0x01	; 1
 5d6:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <SetStatLED2>
		SetStatLED1(false);
 5da:	80 e0       	ldi	r24, 0x00	; 0
 5dc:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <SetStatLED1>
		LED_STAT=true;
 5e0:	81 e0       	ldi	r24, 0x01	; 1
 5e2:	80 93 52 01 	sts	0x0152, r24
 5e6:	08 c0       	rjmp	.+16     	; 0x5f8 <TimerRoutine+0x30>
	}else{
		SetStatLED2(false);
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <SetStatLED2>
		SetStatLED1(true);
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <SetStatLED1>
		LED_STAT=false;
 5f4:	10 92 52 01 	sts	0x0152, r1
	}
	//
	CheckCommandButtons();
 5f8:	0e 94 96 00 	call	0x12c	; 0x12c <CheckCommandButtons>
	RunCommandTasks();
 5fc:	0e 94 4b 01 	call	0x296	; 0x296 <RunCommandTasks>
	if(TmrCntADC<2)
 600:	80 91 53 01 	lds	r24, 0x0153
 604:	90 91 54 01 	lds	r25, 0x0154
 608:	82 30       	cpi	r24, 0x02	; 2
 60a:	91 05       	cpc	r25, r1
 60c:	34 f4       	brge	.+12     	; 0x61a <TimerRoutine+0x52>
	{
		TmrCntADC++;
 60e:	01 96       	adiw	r24, 0x01	; 1
 610:	90 93 54 01 	sts	0x0154, r25
 614:	80 93 53 01 	sts	0x0153, r24
 618:	08 95       	ret
	}else
	{
		DetectTheDot();
 61a:	0e 94 28 02 	call	0x450	; 0x450 <DetectTheDot>
		ProcessTheDot();
 61e:	0e 94 e5 03 	call	0x7ca	; 0x7ca <ProcessTheDot>
		TmrCntADC=0;
 622:	10 92 54 01 	sts	0x0154, r1
 626:	10 92 53 01 	sts	0x0153, r1
 62a:	08 95       	ret

0000062c <Calculate_CRC>:
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 62c:	0f 93       	push	r16
 62e:	1f 93       	push	r17
 630:	cf 93       	push	r28
 632:	df 93       	push	r29
 634:	fc 01       	movw	r30, r24
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
 636:	b2 81       	ldd	r27, Z+2	; 0x02
	uint16_t chksum=0;
	pstrMsg+=3;
 638:	8c 01       	movw	r16, r24
 63a:	0d 5f       	subi	r16, 0xFD	; 253
 63c:	1f 4f       	sbci	r17, 0xFF	; 255
 63e:	60 e0       	ldi	r22, 0x00	; 0
 640:	70 e0       	ldi	r23, 0x00	; 0
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 642:	b5 50       	subi	r27, 0x05	; 5
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 644:	ab 2f       	mov	r26, r27
 646:	a6 95       	lsr	r26
 648:	ca 2f       	mov	r28, r26
 64a:	d0 e0       	ldi	r29, 0x00	; 0
 64c:	ae 01       	movw	r20, r28
 64e:	4f 5f       	subi	r20, 0xFF	; 255
 650:	5f 4f       	sbci	r21, 0xFF	; 255
 652:	44 0f       	add	r20, r20
 654:	55 1f       	adc	r21, r21
 656:	4e 0f       	add	r20, r30
 658:	5f 1f       	adc	r21, r31
 65a:	08 c0       	rjmp	.+16     	; 0x66c <Calculate_CRC+0x40>
	{
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
 65c:	31 81       	ldd	r19, Z+1	; 0x01
 65e:	20 e0       	ldi	r18, 0x00	; 0
 660:	82 81       	ldd	r24, Z+2	; 0x02
 662:	90 e0       	ldi	r25, 0x00	; 0
 664:	82 2b       	or	r24, r18
 666:	93 2b       	or	r25, r19
 668:	68 0f       	add	r22, r24
 66a:	79 1f       	adc	r23, r25
 66c:	32 96       	adiw	r30, 0x02	; 2
uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
	unsigned char msglen=*(pstrMsg+2)-5;//Not including the checksum bytes
	uint16_t chksum=0;
	pstrMsg+=3;
	while(msglen > 1)
 66e:	e4 17       	cp	r30, r20
 670:	f5 07       	cpc	r31, r21
 672:	a1 f7       	brne	.-24     	; 0x65c <Calculate_CRC+0x30>
#include "GlobalsUI.h"



uint16_t Calculate_CRC(unsigned char* pstrMsg)
{
 674:	aa 0f       	add	r26, r26
 676:	fe 01       	movw	r30, r28
 678:	ee 0f       	add	r30, r30
 67a:	ff 1f       	adc	r31, r31
 67c:	e0 0f       	add	r30, r16
 67e:	f1 1f       	adc	r31, r17
		chksum+=(*(pstrMsg)<<8) | *(pstrMsg+1);
		chksum = chksum & 0xffff;
		msglen-=2;
		pstrMsg+=2;
	}
	if(msglen>0) //If the packet size is odd numbered
 680:	ba 17       	cp	r27, r26
 682:	21 f0       	breq	.+8      	; 0x68c <Calculate_CRC+0x60>
	{
		chksum = chksum^ (int)*(pstrMsg++);
 684:	80 81       	ld	r24, Z
 686:	90 e0       	ldi	r25, 0x00	; 0
 688:	68 27       	eor	r22, r24
 68a:	79 27       	eor	r23, r25
	}
	return(chksum);
}
 68c:	cb 01       	movw	r24, r22
 68e:	df 91       	pop	r29
 690:	cf 91       	pop	r28
 692:	1f 91       	pop	r17
 694:	0f 91       	pop	r16
 696:	08 95       	ret

00000698 <MCU_PKT_CompilePacket>:

bool MCU_PKT_CompilePacket(char cmd, char* pl, int plLen)
{
 698:	cf 93       	push	r28
 69a:	df 93       	push	r29
 69c:	98 2f       	mov	r25, r24
 69e:	db 01       	movw	r26, r22
 6a0:	ea 01       	movw	r28, r20
	// [U][I][msglen][msg_number][msgtype][payload][CRC1][CRC2]
	uint16_t chksum;
	//Header always contain the 0xFA and 0xFB
	MCU_Packet[0]='U';
 6a2:	85 e5       	ldi	r24, 0x55	; 85
 6a4:	80 93 1f 01 	sts	0x011F, r24
	MCU_Packet[1]='I';
 6a8:	89 e4       	ldi	r24, 0x49	; 73
 6aa:	80 93 20 01 	sts	0x0120, r24
	iPktSize=plLen+7;
 6ae:	27 96       	adiw	r28, 0x07	; 7
 6b0:	d0 93 18 01 	sts	0x0118, r29
 6b4:	c0 93 17 01 	sts	0x0117, r28
 6b8:	27 97       	sbiw	r28, 0x07	; 7
	if ( plLen+7 > 20 ) //SABT can handle packets upto 20 bytes 
 6ba:	ce 30       	cpi	r28, 0x0E	; 14
 6bc:	d1 05       	cpc	r29, r1
 6be:	14 f0       	brlt	.+4      	; 0x6c4 <MCU_PKT_CompilePacket+0x2c>
 6c0:	80 e0       	ldi	r24, 0x00	; 0
 6c2:	22 c0       	rjmp	.+68     	; 0x708 <MCU_PKT_CompilePacket+0x70>
	{
		return(false);
	}
	MCU_Packet[2] = plLen+7;
 6c4:	9e 01       	movw	r18, r28
 6c6:	29 5f       	subi	r18, 0xF9	; 249
 6c8:	20 93 21 01 	sts	0x0121, r18
	MCU_Packet[3] = 2;	
 6cc:	82 e0       	ldi	r24, 0x02	; 2
 6ce:	80 93 22 01 	sts	0x0122, r24
	MCU_Packet[4] = cmd;	
 6d2:	90 93 23 01 	sts	0x0123, r25
 6d6:	20 e0       	ldi	r18, 0x00	; 0
 6d8:	30 e0       	ldi	r19, 0x00	; 0
 6da:	07 c0       	rjmp	.+14     	; 0x6ea <MCU_PKT_CompilePacket+0x52>
	int i=0;
	for(i=0;i<plLen;i++)
	{
		MCU_Packet[5+i]=*(pl++);
 6dc:	8d 91       	ld	r24, X+
 6de:	f9 01       	movw	r30, r18
 6e0:	ec 5d       	subi	r30, 0xDC	; 220
 6e2:	fe 4f       	sbci	r31, 0xFE	; 254
 6e4:	80 83       	st	Z, r24
	}
	MCU_Packet[2] = plLen+7;
	MCU_Packet[3] = 2;	
	MCU_Packet[4] = cmd;	
	int i=0;
	for(i=0;i<plLen;i++)
 6e6:	2f 5f       	subi	r18, 0xFF	; 255
 6e8:	3f 4f       	sbci	r19, 0xFF	; 255
 6ea:	2c 17       	cp	r18, r28
 6ec:	3d 07       	cpc	r19, r29
 6ee:	b4 f3       	brlt	.-20     	; 0x6dc <MCU_PKT_CompilePacket+0x44>
	{
		MCU_Packet[5+i]=*(pl++);
	}
	//memcpy( &MCU_Packet[5], pl, plLen);
	chksum = Calculate_CRC((unsigned char*)MCU_Packet);
 6f0:	8f e1       	ldi	r24, 0x1F	; 31
 6f2:	91 e0       	ldi	r25, 0x01	; 1
 6f4:	0e 94 16 03 	call	0x62c	; 0x62c <Calculate_CRC>
	MCU_Packet[plLen+5] = chksum >> 8;
 6f8:	fe 01       	movw	r30, r28
 6fa:	ec 5d       	subi	r30, 0xDC	; 220
 6fc:	fe 4f       	sbci	r31, 0xFE	; 254
 6fe:	90 83       	st	Z, r25
	MCU_Packet[plLen+6] = chksum & 0xFF;	
 700:	cb 5d       	subi	r28, 0xDB	; 219
 702:	de 4f       	sbci	r29, 0xFE	; 254
 704:	88 83       	st	Y, r24
 706:	81 e0       	ldi	r24, 0x01	; 1
	return(true);
}
 708:	df 91       	pop	r29
 70a:	cf 91       	pop	r28
 70c:	08 95       	ret

0000070e <SendPacket>:

void SendPacket(char cmd, char* payLoad, int plLen)
{
 70e:	cf 93       	push	r28
 710:	df 93       	push	r29
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
 712:	0e 94 4c 03 	call	0x698	; 0x698 <MCU_PKT_CompilePacket>
 716:	88 23       	and	r24, r24
 718:	89 f0       	breq	.+34     	; 0x73c <SendPacket+0x2e>
 71a:	c0 e0       	ldi	r28, 0x00	; 0
 71c:	d0 e0       	ldi	r29, 0x00	; 0
 71e:	07 c0       	rjmp	.+14     	; 0x72e <SendPacket+0x20>
	{
		for(i=0;i<iPktSize;i++)
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
 720:	fe 01       	movw	r30, r28
 722:	e1 5e       	subi	r30, 0xE1	; 225
 724:	fe 4f       	sbci	r31, 0xFE	; 254
 726:	80 81       	ld	r24, Z
 728:	0e 94 ab 02 	call	0x556	; 0x556 <USART_transmitByteToMCU>
void SendPacket(char cmd, char* payLoad, int plLen)
{
	int i=0;
	if(MCU_PKT_CompilePacket(cmd,payLoad,plLen))
	{
		for(i=0;i<iPktSize;i++)
 72c:	21 96       	adiw	r28, 0x01	; 1
 72e:	80 91 17 01 	lds	r24, 0x0117
 732:	90 91 18 01 	lds	r25, 0x0118
 736:	c8 17       	cp	r28, r24
 738:	d9 07       	cpc	r29, r25
 73a:	94 f3       	brlt	.-28     	; 0x720 <SendPacket+0x12>
		{
			USART_transmitByteToMCU(MCU_Packet[i]);
		}
	}	

}
 73c:	df 91       	pop	r29
 73e:	cf 91       	pop	r28
 740:	08 95       	ret

00000742 <ResetCellState>:
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 742:	10 92 19 01 	sts	0x0119, r1
 746:	10 92 1a 01 	sts	0x011A, r1
 74a:	10 92 1b 01 	sts	0x011B, r1
 74e:	10 92 1c 01 	sts	0x011C, r1
 752:	10 92 1d 01 	sts	0x011D, r1
 756:	10 92 1e 01 	sts	0x011E, r1
	}
	PI_LastDotPressed=0;
 75a:	10 92 56 01 	sts	0x0156, r1
}
 75e:	08 95       	ret

00000760 <CaptureCellValue>:
	}
}


void CaptureCellValue(void)
{
 760:	20 e0       	ldi	r18, 0x00	; 0
 762:	30 e0       	ldi	r19, 0x00	; 0
 764:	40 e0       	ldi	r20, 0x00	; 0
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
 766:	61 e0       	ldi	r22, 0x01	; 1
 768:	70 e0       	ldi	r23, 0x00	; 0
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
	{
		if(DotsPressed[i])
 76a:	f9 01       	movw	r30, r18
 76c:	e7 5e       	subi	r30, 0xE7	; 231
 76e:	fe 4f       	sbci	r31, 0xFE	; 254
 770:	80 81       	ld	r24, Z
 772:	88 23       	and	r24, r24
 774:	41 f0       	breq	.+16     	; 0x786 <CaptureCellValue+0x26>
		{
			ProcessedCellValue |= _BV(i);
 776:	cb 01       	movw	r24, r22
 778:	02 2e       	mov	r0, r18
 77a:	02 c0       	rjmp	.+4      	; 0x780 <CaptureCellValue+0x20>
 77c:	88 0f       	add	r24, r24
 77e:	99 1f       	adc	r25, r25
 780:	0a 94       	dec	r0
 782:	e2 f7       	brpl	.-8      	; 0x77c <CaptureCellValue+0x1c>
 784:	48 2b       	or	r20, r24
	/*
	This section process the stored dot values and
	generate a 6-bit number to be send over serial interface
	*/
	ProcessedCellValue=0x00;
	for(i=0;i<6;i++)
 786:	2f 5f       	subi	r18, 0xFF	; 255
 788:	3f 4f       	sbci	r19, 0xFF	; 255
 78a:	26 30       	cpi	r18, 0x06	; 6
 78c:	31 05       	cpc	r19, r1
 78e:	69 f7       	brne	.-38     	; 0x76a <CaptureCellValue+0xa>
 790:	40 93 55 01 	sts	0x0155, r20
		if(DotsPressed[i])
		{
			ProcessedCellValue |= _BV(i);
		}
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
 794:	40 93 01 01 	sts	0x0101, r20
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
 798:	81 e0       	ldi	r24, 0x01	; 1
 79a:	80 93 02 01 	sts	0x0102, r24
	SendPacket('B',(char*)SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
 79e:	82 e4       	ldi	r24, 0x42	; 66
 7a0:	61 e0       	ldi	r22, 0x01	; 1
 7a2:	71 e0       	ldi	r23, 0x01	; 1
 7a4:	42 e0       	ldi	r20, 0x02	; 2
 7a6:	50 e0       	ldi	r21, 0x00	; 0
 7a8:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
void ResetCellState(void)
{
	int i=0;
	for(i=0;i<6;i++)
	{
		DotsPressed[i]=false;
 7ac:	10 92 19 01 	sts	0x0119, r1
 7b0:	10 92 1a 01 	sts	0x011A, r1
 7b4:	10 92 1b 01 	sts	0x011B, r1
 7b8:	10 92 1c 01 	sts	0x011C, r1
 7bc:	10 92 1d 01 	sts	0x011D, r1
 7c0:	10 92 1e 01 	sts	0x011E, r1
	}
	PI_LastDotPressed=0;
 7c4:	10 92 56 01 	sts	0x0156, r1
	}
	SendMsgPayLoad[0]=ProcessedCellValue;	//6-bit number representing the pressed dots
	SendMsgPayLoad[1]=1;					//Cell number is always 1 for the primary interface
	SendPacket('B',(char*)SendMsgPayLoad,2);		//Send the two bytes with messege type of 'B'
	ResetCellState();						//Reset the cell state so that new letter can start
}
 7c8:	08 95       	ret

000007ca <ProcessTheDot>:
void ProcessTheDot(void)
{
	uint8_t TempDot=0;
//	uint8_t PI_ThisDot;
	bool NewDotDetected=false;
	if(!(PINC & (1<<UI_BR1))) //Dot1
 7ca:	34 99       	sbic	0x06, 4	; 6
 7cc:	03 c0       	rjmp	.+6      	; 0x7d4 <ProcessTheDot+0xa>
 7ce:	91 e0       	ldi	r25, 0x01	; 1
 7d0:	81 e0       	ldi	r24, 0x01	; 1
 7d2:	02 c0       	rjmp	.+4      	; 0x7d8 <ProcessTheDot+0xe>
 7d4:	90 e0       	ldi	r25, 0x00	; 0
 7d6:	80 e0       	ldi	r24, 0x00	; 0
	{
		NewDotDetected=true;
		TempDot=1;
	}
	if(!(PINC & (1<<UI_BR2))) //Dot1
 7d8:	31 99       	sbic	0x06, 1	; 6
 7da:	02 c0       	rjmp	.+4      	; 0x7e0 <ProcessTheDot+0x16>
 7dc:	92 e0       	ldi	r25, 0x02	; 2
 7de:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=2;
	}
	if(!(PINC & (1<<UI_BR3))) //Dot1
 7e0:	35 99       	sbic	0x06, 5	; 6
 7e2:	02 c0       	rjmp	.+4      	; 0x7e8 <ProcessTheDot+0x1e>
 7e4:	93 e0       	ldi	r25, 0x03	; 3
 7e6:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=3;
	}
	if(!(PINC & (1<<UI_BR4))) //Dot1
 7e8:	32 99       	sbic	0x06, 2	; 6
 7ea:	02 c0       	rjmp	.+4      	; 0x7f0 <ProcessTheDot+0x26>
 7ec:	94 e0       	ldi	r25, 0x04	; 4
 7ee:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=4;
	}
	if(!(PINC & (1<<UI_BR5))) //Dot1
 7f0:	33 99       	sbic	0x06, 3	; 6
 7f2:	02 c0       	rjmp	.+4      	; 0x7f8 <ProcessTheDot+0x2e>
 7f4:	95 e0       	ldi	r25, 0x05	; 5
 7f6:	81 e0       	ldi	r24, 0x01	; 1
	{
		NewDotDetected=true;
		TempDot=5;
	}
	if(!(PINC & (1<<UI_BR6))) //Dot1
 7f8:	30 99       	sbic	0x06, 0	; 6
 7fa:	02 c0       	rjmp	.+4      	; 0x800 <ProcessTheDot+0x36>
 7fc:	96 e0       	ldi	r25, 0x06	; 6
 7fe:	02 c0       	rjmp	.+4      	; 0x804 <ProcessTheDot+0x3a>
	{
		NewDotDetected=true;
		TempDot=6;
	}

	if(NewDotDetected)
 800:	88 23       	and	r24, r24
 802:	41 f1       	breq	.+80     	; 0x854 <ProcessTheDot+0x8a>
	{
		if(InterfaceType==1)
 804:	80 91 15 01 	lds	r24, 0x0115
 808:	81 30       	cpi	r24, 0x01	; 1
 80a:	49 f0       	breq	.+18     	; 0x81e <ProcessTheDot+0x54>
		{
			//OK this is the default			
		}else if(InterfaceType==2)
 80c:	80 91 15 01 	lds	r24, 0x0115
 810:	82 30       	cpi	r24, 0x02	; 2
 812:	29 f4       	brne	.+10     	; 0x81e <ProcessTheDot+0x54>
		{
			//OK Flip the pattern
			if(TempDot>3) TempDot-=3;
 814:	94 30       	cpi	r25, 0x04	; 4
 816:	10 f0       	brcs	.+4      	; 0x81c <ProcessTheDot+0x52>
 818:	93 50       	subi	r25, 0x03	; 3
 81a:	01 c0       	rjmp	.+2      	; 0x81e <ProcessTheDot+0x54>
			else TempDot+=3;
 81c:	9d 5f       	subi	r25, 0xFD	; 253
		}
		if(PI_LastDotPressed==TempDot) return;
 81e:	80 91 56 01 	lds	r24, 0x0156
 822:	89 17       	cp	r24, r25
 824:	b9 f0       	breq	.+46     	; 0x854 <ProcessTheDot+0x8a>
		PI_LastDotPressed=TempDot;
 826:	90 93 56 01 	sts	0x0156, r25
		DotsPressed[TempDot-1]=true;
 82a:	e9 2f       	mov	r30, r25
 82c:	f0 e0       	ldi	r31, 0x00	; 0
 82e:	e8 5e       	subi	r30, 0xE8	; 232
 830:	fe 4f       	sbci	r31, 0xFE	; 254
 832:	81 e0       	ldi	r24, 0x01	; 1
 834:	80 83       	st	Z, r24
		SendMsgPayLoad[0]=0x30+PI_LastDotPressed;
 836:	90 5d       	subi	r25, 0xD0	; 208
 838:	90 93 01 01 	sts	0x0101, r25
		SendMsgPayLoad[1]=0x31;
 83c:	81 e3       	ldi	r24, 0x31	; 49
 83e:	80 93 02 01 	sts	0x0102, r24
		SendMsgPayLoad[2]=0x31;
 842:	80 93 03 01 	sts	0x0103, r24
    	SendPacket('A',(char*)SendMsgPayLoad,3);
 846:	81 e4       	ldi	r24, 0x41	; 65
 848:	61 e0       	ldi	r22, 0x01	; 1
 84a:	71 e0       	ldi	r23, 0x01	; 1
 84c:	43 e0       	ldi	r20, 0x03	; 3
 84e:	50 e0       	ldi	r21, 0x00	; 0
 850:	0e 94 87 03 	call	0x70e	; 0x70e <SendPacket>
 854:	08 95       	ret

00000856 <__udivmodhi4>:
 856:	aa 1b       	sub	r26, r26
 858:	bb 1b       	sub	r27, r27
 85a:	51 e1       	ldi	r21, 0x11	; 17
 85c:	07 c0       	rjmp	.+14     	; 0x86c <__udivmodhi4_ep>

0000085e <__udivmodhi4_loop>:
 85e:	aa 1f       	adc	r26, r26
 860:	bb 1f       	adc	r27, r27
 862:	a6 17       	cp	r26, r22
 864:	b7 07       	cpc	r27, r23
 866:	10 f0       	brcs	.+4      	; 0x86c <__udivmodhi4_ep>
 868:	a6 1b       	sub	r26, r22
 86a:	b7 0b       	sbc	r27, r23

0000086c <__udivmodhi4_ep>:
 86c:	88 1f       	adc	r24, r24
 86e:	99 1f       	adc	r25, r25
 870:	5a 95       	dec	r21
 872:	a9 f7       	brne	.-22     	; 0x85e <__udivmodhi4_loop>
 874:	80 95       	com	r24
 876:	90 95       	com	r25
 878:	bc 01       	movw	r22, r24
 87a:	cd 01       	movw	r24, r26
 87c:	08 95       	ret

0000087e <_exit>:
 87e:	f8 94       	cli

00000880 <__stop_program>:
 880:	ff cf       	rjmp	.-2      	; 0x880 <__stop_program>
